---
title: "v0.1.0 Critical Architecture and Implementation Review"
label: devflow.reference.v010-critical-review
date: 2026-02-26
---

# v0.1.0 Critical Architecture and Implementation Review

## 1. Review Summary

This review examines the `devflow` project across its architecture documents (~1800 lines) and implementation (~350 lines of Rust). The project aims to be a generic, stack-agnostic workflow orchestration CLI. The vision is sound: unifying local and CI developer workflows behind a stable command contract is a real problem worth solving. However, the current state has significant structural risks that should be addressed before committing further implementation effort.

Severity ratings used below:

- **Critical**: blocks correctness or viability of the v0.1.0 design.
- **Major**: creates substantial rework risk or undermines stated goals.
- **Minor**: worth addressing but does not block progress.

---

## 2. Critical Findings

### 2.1 No Execution Engine Exists

**Severity: Critical**

The architecture document describes a "DAG Executor" as the heart of `devflow-core` (Section 3, Section 7). The execution model specifies 8 steps: load config, resolve extensions, build DAG, select runtime, resolve identity, restore caches, execute task graph, emit status.

The implementation contains none of this. The `execute` function in `devflow-cli/src/main.rs:46-75` is a `match` statement that prints strings:

```rust
// The entire "execution engine" today:
println!(
    "run {} (runtime={:?}, project={}, stack={})",
    command, cfg.runtime.profile, cfg.project.name,
    cfg.project.stack.join(",")
);
```

There is no process spawning, no shell execution, no container interaction, no DAG construction, and no task scheduling. The gap between the documented architecture and the implementation is not incremental --- it is foundational. The core value proposition (actually running commands) does not exist.

**Recommendation**: Strip the architecture document back to what can be delivered incrementally. Define a Phase 0 that delivers a single command executing a single shell process, then layer DAG, caching, and container support on top.

### 2.2 Extensions Are Inert Capability Lists

**Severity: Critical**

The architecture describes extensions as modules that "map canonical commands to executable actions" (Section 10). The extension loading lifecycle specifies 7 steps including health probes and command dispatch registration.

In practice, `devflow-ext-rust/src/lib.rs` and `devflow-ext-node/src/lib.rs` are static arrays of string literals:

```rust
pub fn default_capabilities() -> &'static [&'static str] {
    &["setup", "fmt:check", "fmt:fix", ...]
}
```

These crates have zero dependencies. They contain no logic, no trait implementations, no command-to-toolchain mapping, and no execution adapters. They are not even referenced by `devflow-core` or `devflow-cli` in `Cargo.toml` --- the CLI reads capabilities from `devflow.toml`, making these crates entirely dead code.

**Recommendation**: Either remove the extension crates until they serve a purpose, or define the `Extension` trait now and implement at least one concrete command (e.g., `fmt:check` mapping to `cargo fmt --check` for Rust). Dead crates create a false sense of progress.

### 2.3 Document-Implementation Drift Is Already Present

**Severity: Critical**

Multiple inconsistencies exist between the architecture documents and the implementation:

| Aspect | Architecture Doc | Implementation |
| --- | --- | --- |
| Config `[container]` section | Specified in Section 6 schema | Not in `DevflowConfig` struct |
| Config `[cache]` section | Specified in Section 6 schema | Not in `DevflowConfig` struct |
| Cache env var | `DEVFLOW_CACHE_ROOT` (arch doc) vs `KROKI_CACHE_ROOT` (CI doc) | Neither exists |
| Fingerprint inputs | Defined in Section 8 | No fingerprinting code |
| Extension discovery | Built-in + path (Section 10) | Config-driven only; `devflow-ext-*` crates unused |
| GH Actions job topology | prep/build/parallel-verify (Section 9) | Hardcoded single-job stub |
| `devflow.lock` | Proposed in Section 10 | No lock file support |

The project has already accumulated specification debt before implementation has begun. With six reference documents and only one function that does real work (`DevflowConfig::load_from_file`), the drift will accelerate.

**Recommendation**: Adopt a rule that no architectural section is approved until a conformance test exists for it. Delete or explicitly mark sections as "planned" vs "implemented".

---

## 3. Major Findings

### 3.1 Over-Specification Relative to Validation

**Severity: Major**

The ratio of documentation to implementation is approximately 5:1 by line count. The project has:

- 5 reference/architecture documents (~1800 lines)
- 6 Rust crates (~350 lines of source)
- 3 unit tests total (command parsing: 3, policy: 1 with overlap)

For a v0.1.0 that has not yet validated its core loop (can it actually run `cargo fmt`?), this level of specification creates two risks:

1. **Sunk cost anchoring**: future implementation choices will be constrained by documents that were written without implementation feedback.
2. **False confidence**: the review checklist (Section 13) implies readiness gates that the codebase cannot satisfy.

**Recommendation**: Invert the approach. Build a walking skeleton that runs `dwf fmt:check` end-to-end for a Rust project (config load to shell execution to exit code), then validate the architecture against that experience.

### 3.2 Target Profiles Are Hardcoded to Three Branch Strategies

**Severity: Major**

`TargetsConfig` supports exactly three profiles: `pr`, `main`, `release`. The policy resolver hardcodes these as a match:

```rust
match selector {
    "pr" => &cfg.targets.pr,
    "main" => &cfg.targets.main,
    "release" => &cfg.targets.release,
    _ => return Err(...)
}
```

The stated goal is to "scale across different types of branching styles" but the implementation cannot support `develop`, `staging`, `hotfix`, feature-branch gates, or any custom profile. Adding a new target requires modifying two Rust files and recompiling.

**Recommendation**: Replace the fixed struct with `HashMap<String, Vec<String>>` in `TargetsConfig`. The policy resolver should look up by key, not by match arm. This is a one-line structural change now but a painful migration later.

### 3.3 The GH Actions Renderer Cannot Fulfill Its Contract

**Severity: Major**

The architecture states that CI YAML should contain "orchestration only" and that job topology should include prep, build, and parallel verify jobs (Section 9). The renderer generates:

```yaml
jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: dwf check:pr
```

This is a hardcoded string that ignores the config entirely (no target profiles, no container image, no cache config, no parallel jobs). It references `dwf` which would not be installed in a fresh CI runner. The function signature accepts `&DevflowConfig` but only uses `cfg.project.name` for a comment.

**Recommendation**: Either remove the renderer until it can generate workflows from config, or rename it to `render_placeholder` to set correct expectations. The current name `render_workflow_stub` in a crate called `devflow-gh` suggests more capability than exists.

### 3.4 Bootstrapping Paradox Is Unaddressed

**Severity: Major**

`devflow` uses `devflow.toml` to configure its own development workflow. The Makefile targets invoke `cargo run -p devflow-cli --` which compiles the tool before running it. This creates a bootstrapping problem:

1. A new contributor must have Rust installed to run `dwf setup`, but `dwf setup` is supposed to install Rust.
2. CI must build `devflow-cli` before it can use it to orchestrate the CI pipeline.
3. If `devflow.toml` parsing breaks, the tool cannot diagnose itself.

**Recommendation**: Document the bootstrap contract explicitly. Define what must exist before `dwf` can run (minimum: Rust toolchain, `devflow.toml`). Consider a pre-compiled binary distribution path for CI (which the Homebrew plan partially addresses, but is deferred).

### 3.5 No Selector Validation

**Severity: Major**

`CommandRef::from_str` validates the primary command but accepts any string as a selector. `test:banana`, `fmt:yolo`, and `build:!!!` all parse successfully. Validation only occurs at extension capability checking, which means:

- Typos in `devflow.toml` target lists (e.g., `test:untit` instead of `test:unit`) are silent until `check` is invoked at runtime.
- The error message surfaces as "no extension exposes capability 'test:untit'" rather than "unknown selector 'untit' for command 'test'".

**Recommendation**: Add a known-selector registry or at minimum a warning when a selector is not recognized by any loaded extension during config validation, not just at execution time.

---

## 4. Minor Findings

### 4.1 Implicit Default in `check` Command

The CLI defaults `check` without a selector to `check:pr` (`main.rs:49`). This is a silent assumption that could surprise users who expect `check` alone to run all profiles or to require an explicit selector. The behavior should be documented or made explicit (require a selector).

### 4.2 Dual CLI Syntax Creates Ambiguity

The CLI accepts both `dwf test:unit` (colon syntax) and `dwf test unit` (space syntax). The space syntax is implemented by concatenating positional arguments (`main.rs:24-27`). This creates edge cases:

- `dwf check pr` works, but `dwf check:pr` also works.
- `dwf ci render` works, but what about `dwf ci:render`? Both work, but through different code paths.
- Three-word commands (`dwf ci render plan`) would silently ignore the third argument.

**Recommendation**: Pick one canonical syntax and alias the other, or validate that no extra arguments are silently dropped.

### 4.3 Legacy Naming Artifacts

The CI redesign document (`v0.1.0-ci-container-redesign.md`) still references `KROKI_CACHE_ROOT`, `kroki-rs`, and `./dflow`. The label metadata uses `kroki-rs.developer-guide.*` instead of `devflow.*`. This suggests the document was migrated from a predecessor project without full cleanup.

### 4.4 Extension Crates Have No Consumers

Neither `devflow-ext-rust` nor `devflow-ext-node` appear as dependencies in any other crate's `Cargo.toml`. The capabilities declared in `devflow.toml` duplicate what these crates export, making them orphaned. If the intent is for extensions to be compile-time linked, the dependency chain is missing. If capabilities are purely config-driven, the crates are unnecessary.

### 4.5 Test Coverage Is Minimal

The project has 4 test assertions across 2 crates:

- `devflow-core`: 3 tests for command parsing.
- `devflow-policy`: 1 test for PR profile resolution.
- `devflow-cli`: 0 tests.
- `devflow-gh`: 0 tests.
- `devflow-core::config`: 0 tests.
- `devflow-core::extension`: 0 tests.

Key untested paths include config loading, extension discovery, capability validation, legacy alias mapping, and the CLI argument parser.

### 4.6 Makefile Adds No Value Over Direct CLI Invocation

Every Makefile target is `cargo run -p devflow-cli -- <command>`. The Makefile does not add caching, environment setup, help text, or error handling. It exists to demonstrate the command mapping but a developer could run `cargo run -p devflow-cli -- check:pr` directly. Once `dwf` is installed, the Makefile becomes fully redundant.

### 4.7 Config Validation is Load-Time Only

`DevflowConfig::load_from_file` deserializes TOML and returns. There is no post-parse validation:

- `stack` values are not checked against known stacks or available extensions.
- Target command strings are not validated against the command grammar.
- Extension `version` strings are not parsed as semver ranges (they are stored as `Option<String>`).
- `required = true` on an extension has no effect --- there is no check that required extensions are actually loaded.

---

## 5. Structural Risks

### 5.1 Premature Crate Decomposition

Six crates for ~350 lines of code means an average of ~58 lines per crate. `devflow-gh` is 11 lines. `devflow-ext-node` is 17 lines. This decomposition optimizes for a future state that does not exist yet and creates friction:

- Every cross-crate change requires coordinating `Cargo.toml` dependencies.
- Compile times increase due to crate boundary overhead.
- Refactoring is harder when types must be `pub` for cross-crate access.

**Recommendation**: Start with 2 crates (`devflow-core` and `devflow-cli`). Extract `policy`, `gh`, and extensions into separate crates only when they have sufficient complexity to justify the boundary (100+ lines with distinct dependency requirements is a reasonable threshold).

### 5.2 Architecture Assumes Features That Do Not Exist in Rust's Type System

The extension lifecycle describes "health probes", "capability contracts", and "runtime adapters" but the implementation uses no traits, no dynamic dispatch, and no plugin loading. The jump from static string arrays to a functioning extension system requires:

- A trait defining the extension interface.
- A mechanism for extensions to register command handlers.
- Either static dispatch (compile-time linked) or dynamic dispatch (dylib/WASM/subprocess).

None of these design choices have been made or prototyped. The architecture document leaves the most difficult technical decision (how extensions actually execute code) unresolved.

### 5.3 Cross-Stack Ambition vs Single-Stack Reality

The project targets Rust, Node, React, Lit, VS Code, and Tauri stacks. But v0.1.0 cannot execute a single command for a single stack. Designing for six stacks before validating one creates risk of premature abstraction. The command mapping table in the CI redesign doc maps 9 commands across 5 stacks (45 mappings) --- none of which are implemented.

---

## 6. What Works Well

Despite the critical findings, several design choices are strong:

1. **The primary/secondary command model is well-designed.** The `command:selector` syntax is intuitive, extensible, and avoids the "too many top-level commands" problem. The decision to reject narrow commands (`unit-test`, `integration-test`) in favor of selectors is correct.

2. **Policy-driven composition is the right abstraction.** Having `check:pr` expand to a configured list of commands rather than hardcoding what a PR check means is a good separation of concerns.

3. **The container-first, cache-as-optimization principle is sound.** Treating caches as acceleration-only and requiring correctness without cache hits is a strong foundation for reproducible builds.

4. **Config-driven extension capabilities are pragmatic.** For v0.1.0, declaring capabilities in TOML rather than building a plugin runtime is the right scoping decision --- if the architecture documents reflected this reality.

5. **The workspace structure is clean.** Cargo workspace with shared dependency versions, consistent naming, and clear crate purposes (once they have implementations).

---

## 7. Recommendations (Prioritized)

### Immediate (before further implementation)

1. **Build a walking skeleton.** Make `dwf fmt:check` actually run `cargo fmt --check` for a Rust project. This single vertical slice will validate or invalidate more assumptions than any document.

2. **Reconcile docs with code.** Mark every architecture section as `status: implemented | in-progress | planned`. Remove or gate sections that are purely aspirational.

3. **Make targets dynamic.** Replace the fixed `pr/main/release` struct with a `HashMap<String, Vec<String>>`. This is a 15-minute change now and a breaking change later.

4. **Consolidate crates.** Merge `devflow-policy`, `devflow-gh`, `devflow-ext-rust`, and `devflow-ext-node` into `devflow-core` until each justifies its own crate. Remove dead code.

### Short-term (during v0.1.0 implementation)

5. **Define the Extension trait.** Even if v0.1.0 only has compile-time linked extensions, define the trait boundary now. This is the most consequential API decision in the project.

6. **Add config validation.** Validate target command references, stack names, extension requirements, and semver ranges at config load time.

7. **Add integration tests.** Test the CLI end-to-end: config loading through command resolution through (eventual) execution. The current 4 unit tests do not cover the critical paths.

### Medium-term (v0.1.0 completion)

8. **Resolve the extension execution model.** Decide between compile-time dispatch, subprocess delegation (like `cargo-<subcommand>`), or a trait-object approach. This cannot remain unresolved.

9. **Clean up legacy references.** Remove all `kroki-rs`, `KROKI_CACHE_ROOT`, and `dflow` references from the docs. The project has its own identity now.

10. **Write a contributor onboarding guide.** The current 5-document architecture corpus is not approachable. A single "how devflow works" page with a diagram and 3 code examples would be more useful than all existing reference docs combined.

---

## 8. Conclusion

The `devflow` project has a clear and valuable vision: a stack-agnostic, deterministic workflow CLI that unifies local and CI development. The command model is well-thought-out and the separation between orchestration core and stack extensions is architecturally sound.

The primary risk is not bad design --- it is premature specification. The project has invested heavily in documenting a system that does not yet exist, creating a gap between stated architecture and actual capability. This gap will widen if implementation follows the documents literally rather than iterating from a working vertical slice.

The path forward is to build the thinnest possible working system (one config, one command, one stack, one execution), validate the architectural assumptions against that reality, and then expand. The documents should follow the code, not lead it.
