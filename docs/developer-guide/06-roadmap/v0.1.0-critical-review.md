---
title: "v0.1.0 Critical Architecture and Implementation Review"
label: devflow.developer-guide.roadmap.v010-critical-review
date: 2026-02-26
---

# v0.1.0 Critical Architecture and Implementation Review

## 1. Review Summary

This is the second revision of the critical review, updated after substantial implementation
changes that addressed several findings from revision 1.

The project has moved from a documentation-only state to a functional walking skeleton.
Commands now execute real processes, target profiles are dynamic, the GH Actions renderer
generates proper multi-job topologies, config validation rejects invalid inputs, and the
extension crates are no longer dead code. This is significant progress.

The remaining concerns have shifted from "nothing works" to "the execution model has
architectural misplacement and the doc-code contract still has gaps." These are solvable
at this stage but will calcify if deferred.

Severity ratings:

- **Critical**: blocks correctness or viability of the v0.1.0 design.
- **Major**: creates substantial rework risk or undermines stated goals.
- **Minor**: worth addressing but does not block progress.
- **Resolved**: addressed since revision 1.

---

## 2. Resolved Findings

### 2.1 Execution Engine Now Exists

**Previous severity: Critical | Status: Resolved**

The new `executor.rs` module in `devflow-cli` spawns real processes via
`std::process::Command`. It resolves stacks from config, detects project manifests
(`Cargo.toml`, `package.json`), maps canonical commands to toolchain-specific argv
vectors, and propagates exit codes. `dwf fmt:check` now actually runs
`cargo fmt --all -- --check`. This is the walking skeleton that was recommended.

### 2.2 Extension Crates Are No Longer Dead Code

**Previous severity: Critical | Status: Resolved**

`devflow-core/Cargo.toml` now depends on `devflow-ext-rust` and `devflow-ext-node`.
The `builtin_capabilities()` function in `extension.rs` calls into these crates when
config does not declare explicit capabilities. The extension crates now serve a concrete
purpose in the dependency graph.

### 2.3 Target Profiles Are Dynamic

**Previous severity: Major | Status: Resolved**

`TargetsConfig` now uses `HashMap<String, Vec<String>>` with `#[serde(flatten)]`. The
policy resolver uses `.get(selector)` instead of a hardcoded match. Custom profiles like
`develop`, `staging`, or `hotfix` work without code changes. The architecture doc was
updated to document this as "dynamic map keys." Clean fix.

### 2.4 GH Actions Renderer Generates Real Workflows

**Previous severity: Major | Status: Resolved**

`render_workflow` now generates prep/build/parallel-check topology from the `pr` target
profile. `check_workflow` validates rendered output against expected structure. The
`sanitize_job_name` helper handles special characters. Three tests cover the render and
validation paths. This is a substantive improvement.

### 2.5 Config Validation Exists

**Previous severity: Minor | Status: Resolved**

`DevflowConfig` now uses `#[serde(deny_unknown_fields)]` on key structs. A `validate()`
method checks stack names against known values and parses all target command references
at load time. Unknown top-level keys, unknown project keys, and invalid command strings
in target profiles all fail fast with actionable errors. Two new tests cover rejection
paths.

### 2.6 Extension Target Validation

**Previous severity: Minor (selector validation) | Status: Partially resolved**

`ExtensionRegistry::validate_target_support` now validates that every command in every
target profile is covered by at least one extension's capabilities. This runs at startup,
catching typos like `test:untit` before any execution attempt. Two new tests cover this
path. The remaining gap: arbitrary selectors still parse successfully at the `CommandRef`
level; validation depends on the extension registry being populated.

### 2.7 Test Coverage Improved

**Previous severity: Minor | Status: Partially resolved**

Test count has increased from 4 to approximately 10, now covering config rejection,
extension target validation, workflow rendering, and workflow checking. Key gaps remain
(see Section 4.4).

---

## 3. Critical Findings

### 3.1 Command-to-Toolchain Mapping Lives in the Wrong Layer

**Severity: Critical**

The architecture states that extensions "map canonical commands to executable actions"
(Section 10) and that "stack-specific logic lives in `devflow-ext-*`" (Section 3). The
implementation does the opposite: all command-to-toolchain mapping is in
`devflow-cli/src/executor.rs`, a CLI module.

`executor.rs` contains `map_rust()` and `map_node()` functions with hardcoded argv
vectors:

```rust
// In devflow-cli/src/executor.rs â€” not in devflow-ext-rust
fn map_rust(cmd: &CommandRef) -> Option<Vec<&'static str>> {
    match (cmd.primary, selector) {
        (PrimaryCommand::Fmt, "check") => Some(vec!["cargo", "fmt", "--all", "--", "--check"]),
        // ...
    }
}
```

Meanwhile, `devflow-ext-rust/src/lib.rs` only exports a static capability list. The
actual "extension" logic (what `fmt:check` means for Rust) lives in the CLI crate, not
in the extension crate. This creates three problems:

1. **Architectural violation**: the core/extension boundary documented in Section 3 is
   not honored. Adding a new stack requires modifying the CLI, not writing an extension.
2. **Capability/execution mismatch**: an extension can claim `lint:security` as a
   capability, but if `executor.rs` has no match arm for it, the command will fail with
   "did not match any runnable stack" despite passing capability validation.
3. **Extension crates cannot evolve independently**: since they hold no execution logic,
   their `version` field is meaningless.

**Recommendation**: Move `map_rust` and `map_node` into their respective extension
crates (or into `devflow-core` behind an `Extension` trait). The extension crate should
own both the capability declaration and the command mapping. The CLI should call
`extension.map_command(cmd)` rather than maintaining its own stack-specific match arms.

### 3.2 Architecture Document Schema Contradicts `deny_unknown_fields`

**Severity: Critical**

The architecture document (Section 6) shows this as the minimum config schema:

```toml
[container]
image = "ghcr.io/org/repo-ci"
fingerprint_inputs = ["Dockerfile", "Makefile", ...]

[cache]
root = ".cache/devflow"
strategy = "layered"
```

But `DevflowConfig` now uses `#[serde(deny_unknown_fields)]`. Any user who copies the
documented schema will get a parse error because `[container]` and `[cache]` are unknown
fields. The document promises a config contract that the implementation actively rejects.

This is worse than the drift in revision 1 because the validation is now stricter. Before,
unknown keys were silently accepted; now they are hard errors, making the documented schema
a guaranteed failure path.

**Recommendation**: Either remove `[container]` and `[cache]` from the architecture
document's schema example (marking them as planned for a future version), or add
placeholder structs with `#[serde(default)]` so the keys are accepted without
implementation. Do not document fields that the parser rejects.

---

## 4. Major Findings

### 4.1 `ci:check` Validates Its Own Output, Not the Committed Workflow

**Severity: Major**

The `ci:check` command in `main.rs:77-82` does this:

```rust
PrimaryCommand::Ci if command.selector.as_deref() == Some("check") => {
    let workflow = devflow_gh::render_workflow(cfg)?;
    devflow_gh::check_workflow(cfg, &workflow)?;
    println!("ci:check passed");
    Ok(())
}
```

It renders a workflow from config, then validates that same rendered output. This is a
tautology: `ci:check` will always pass because it is checking the renderer's output
against the renderer's own expectations. The useful check would be to read the committed
`.github/workflows/ci.yml` from disk and validate it against the config, detecting
when the committed workflow has drifted from what `ci:generate` would produce.

**Recommendation**: `ci:check` should read the workflow file from disk (defaulting to
`--ci-output` path) and validate that against the config. The current implementation
should be renamed to something like `ci:validate-render` or removed, since a self-check
provides no signal.

### 4.2 Rust Test Selectors Have Overlapping Scope

**Severity: Major**

The test command mappings in `executor.rs` are:

```rust
(PrimaryCommand::Test, "unit") => Some(vec!["cargo", "test", "--lib", "--bins"]),
(PrimaryCommand::Test, "integration") => Some(vec!["cargo", "test", "--tests"]),
```

`cargo test --tests` runs all targets in the `tests/` directory **and** `#[test]`
functions in `--lib` and `--bins`. This means `test:integration` re-runs all unit tests.
The `--tests` flag in Cargo means "run test targets" (the `[[test]]` sections), but it
also includes lib and bin test targets by default.

A PR target of `["test:unit", "test:integration"]` will execute unit tests twice. For a
project with a large test suite, this doubles CI time for no benefit.

**Recommendation**: Use `cargo test --test '*'` for integration (runs only files in
`tests/` directory) or `cargo nextest run --partition-by=test-type` if adopting nextest
as the architecture document's CI redesign proposes.

### 4.3 Bootstrapping Paradox Remains Unaddressed

**Severity: Major**

This finding is unchanged from revision 1. `devflow` uses `devflow.toml` to configure
its own build. The Makefile compiles the CLI before running it. CI must build `devflow-cli`
before it can use it. No documentation addresses what must exist before `dwf` runs.

The generated `.github/workflows/ci.yml` references `dwf build:debug` and `dwf <command>`
but does not include a step to install `dwf`. A CI runner executing this workflow will fail
at the first `dwf` invocation.

**Recommendation**: The generated workflow must include either a `dwf` installation step
(e.g., `cargo install` or download from releases) or fall back to
`cargo run -p devflow-cli --`. Document the bootstrap prerequisites explicitly.

### 4.4 Executor Has No Tests

**Severity: Major**

`executor.rs` is the most consequential module in the project --- it is the only code that
actually does work. It has zero tests. The following behaviors are untested:

- Stack resolution from config
- Manifest detection (`stack_is_applicable`)
- Default selector assignment (`with_default_selector`)
- Command mapping for Rust (14 match arms)
- Command mapping for Node (11 match arms)
- Behavior when no stack matches
- Behavior when stack manifest is missing
- Process exit code propagation

The command mapping functions are pure (input to output, no side effects) and trivially
testable. The manifest detection could be tested with a temp directory.

**Recommendation**: Add unit tests for `map_rust`, `map_node`, `with_default_selector`,
and `resolve_stacks` at minimum. These are the highest-value tests in the entire project.

---

## 5. Minor Findings

### 5.1 Implicit Default in `check` Command

**Status: Still open from revision 1**

`check` without a selector still defaults silently to `check:pr` (`main.rs:57`). This
may surprise users who expect `check` alone to require an explicit selector. All other
primary commands get defaults via `with_default_selector`, but `check` is handled
separately in the `execute` match, creating an inconsistency in how defaults are applied.

### 5.2 Dual CLI Syntax Creates Ambiguity

**Status: Still open from revision 1**

Both `dwf test:unit` and `dwf test unit` work. The space syntax concatenates positional
arguments. Three-word invocations (`dwf ci generate foo`) silently drop extra arguments.
No validation ensures completeness.

### 5.3 Legacy Naming Artifacts

**Status: Still open from revision 1**

`v0.1.0-ci-container-redesign.md` still references `KROKI_CACHE_ROOT`, `kroki-rs`, and
`./dflow`. The label uses `kroki-rs.developer-guide.*` instead of `devflow.*`.

### 5.4 `devflow.toml` Declares Node Stack With No Node Project

The project's own `devflow.toml` declares `stack = ["rust", "node"]` but there is no
`package.json` in the repository. Every command execution will print
"skip node: manifest not found". This is noisy and misleading for anyone running
the project's own workflow. Either add a minimal `package.json` or remove `"node"`
from the stack list.

### 5.5 `stack_is_applicable` Uses Relative Paths

`Path::new("Cargo.toml").exists()` depends on the current working directory. If a user
runs `dwf fmt:check` from a subdirectory or with `--config /other/path/devflow.toml`,
the manifest check will fail even though the project root has a `Cargo.toml`. There is
no project root resolution.

**Recommendation**: Derive the project root from the config file path and resolve
manifests relative to that root.

### 5.6 Node Stack Hardcodes `npm`

All Node command mappings use `npm` (`npm ci`, `npm run fmt:check`, etc.). The CI redesign
document extensively references `pnpm`. There is no detection of `pnpm`/`yarn` via lockfile
presence, no config option to select a package manager, and no environment variable override.

### 5.7 `with_default_selector` Maps `setup` to `doctor`

`setup` intuitively means "set things up" (install toolchains, sync dependencies).
Mapping bare `setup` to `setup:doctor` (which runs `cargo --version` or `npm --version`)
is surprising. A user running `dwf setup` expecting environment preparation will instead
get a version check.

### 5.8 Hardcoded `&'static str` Argv Prevents Configuration

Command mappings return `Vec<&'static str>`. This means:

- Users cannot pass extra flags (e.g., `--workspace` to cargo commands).
- `cargo clippy` always uses `--all-features`, which may not be desired.
- `cargo test` cannot target specific test names or use nextest.
- No config-driven overrides for any toolchain invocation.

This is acceptable for a v0.1.0 walking skeleton but will be the first friction point
for real-world adoption.

### 5.9 Makefile Remains a Thin Wrapper

**Status: Still open from revision 1**

Every Makefile target is still `cargo run -p devflow-cli -- <command>` with no added value.

---

## 6. Structural Observations

### 6.1 Crate Decomposition Is More Justified Now

Revision 1 flagged 6 crates for ~350 lines as premature. The codebase has grown:
`devflow-gh` is now ~95 lines with 3 tests, `executor.rs` is ~179 lines, and
`extension.rs` has ~130 lines with tests. While some crates remain small
(`devflow-ext-node`: 17 lines, `devflow-ext-rust`: 18 lines), the overall structure
is more proportionate. The extension crates will need to grow significantly once the
command mapping moves into them (per finding 3.1).

### 6.2 The Extension Trait Decision Remains the Central Open Question

The most consequential unresolved design decision is how extensions execute commands.
Currently, `executor.rs` uses a function-per-stack approach with static dispatch. The
architecture document describes a lifecycle with health probes and runtime adapters. The
gap between these two models needs to be closed. Three viable options exist:

1. **Trait objects in core**: define `trait Extension { fn map_command(&self, cmd) -> Argv; }`,
   implement in each ext crate, register in core. Simplest, works for compiled-in extensions.
2. **Subprocess delegation**: extensions are separate binaries (`devflow-ext-rust` as CLI),
   core invokes them. Enables third-party extensions without recompilation.
3. **Config-driven mapping**: move the match tables into TOML/JSON files within extension
   crates, load at runtime. No trait needed, but limits logic.

Option 1 is the pragmatic choice for v0.1.0. Option 2 is the scaling choice.

---

## 7. What Works Well

Strengths carried forward from revision 1, reinforced by changes:

1. **The primary/secondary command model** remains well-designed and is now validated
   end-to-end. The `command:selector` syntax works in practice, not just in docs.

2. **Policy-driven composition** now works with dynamic profiles. `check:staging` or
   `check:hotfix` are trivially addable via config.

3. **Config validation is strict and early.** `deny_unknown_fields` plus the `validate()`
   method catches errors at load time. This is the right posture for a tool that generates
   CI workflows.

4. **The GH renderer now produces useful output.** Prep/build/parallel-check topology
   matches the architecture, and the `check_workflow` validator creates a contract between
   render and verify. The round-trip test (`render` then `check`) is a good pattern.

5. **The executor is clean and extensible.** `run_argv` is simple, `map_command` dispatch
   is straightforward, and the stack-applicability check (manifest detection) is a pragmatic
   heuristic. The module is well-structured for future growth.

6. **The walking skeleton validates the architecture.** The fact that `dwf fmt:check`
   actually runs `cargo fmt --check` proves the config-to-execution pipeline works.
   This is the most important change since revision 1.

---

## 8. Recommendations (Updated and Reprioritized)

### Immediate (before further feature work)

1. **Move command mapping into extension crates.** This is the highest-priority structural
   fix. `map_rust` belongs in `devflow-ext-rust`, not in `devflow-cli`. Define a minimal
   trait or function signature that extensions implement, even if dispatch remains static.

2. **Fix the doc schema.** Remove `[container]` and `[cache]` from the Section 6 example
   or add them as accepted-but-unused fields. The documented schema must parse successfully.

3. **Fix `ci:check` to read committed workflow.** It should validate the file on disk,
   not the renderer's own output.

4. **Fix Rust test scope overlap.** `test:integration` should not re-run unit tests.

### Short-term (during v0.1.0)

5. **Add executor tests.** `map_rust`, `map_node`, `with_default_selector`, and
   `resolve_stacks` are pure functions that should have full test coverage.

6. **Add `dwf` installation step to generated CI.** The workflow is unusable without it.

7. **Resolve project root for manifest detection.** Use the config file location as anchor.

8. **Remove `"node"` from the project's own `devflow.toml`** or add a `package.json`.

### Medium-term (v0.1.0 completion)

9. **Define the Extension trait.** Even a minimal `fn map_command(&self, cmd: &CommandRef) -> Option<Vec<String>>` would formalize the contract.

10. **Add config-driven command overrides.** Allow extensions to accept extra args or
    alternative binaries (e.g., `pnpm` vs `npm`, `nextest` vs `cargo test`).

11. **Clean up legacy references.** The CI redesign doc still carries `kroki-rs` naming.

12. **Document bootstrap prerequisites.** What must exist before `dwf` can run.

---

## 9. Conclusion

The project has made strong progress between revisions. The gap between architecture and
implementation has narrowed substantially: commands execute, config validates, workflows
generate, and extensions participate in the dependency graph. The walking skeleton exists
and works.

The remaining critical issue is structural: command-to-toolchain mapping is in the CLI
rather than in extension crates, which violates the documented architecture and will make
adding new stacks painful. The doc-code schema contradiction is a close second --- it is
a trust issue for anyone adopting the tool.

The path forward is clear: move execution logic into extensions, align the documented
config schema with what the parser accepts, and add tests for the executor. These are
bounded, well-defined tasks that strengthen the foundation without requiring architectural
rethinking.

The project is in a meaningfully better position than at revision 1. It has graduated from
"specification without validation" to "working system with known structural debts." That is
the right trajectory for a v0.1.0.
