# AGENTS.md — devflow

This file provides the context an AI agent needs to understand, navigate, build, test,
and contribute to the `devflow` project. Read this before making any changes.

## Project Purpose

`devflow` (binary: `dwf`) is a deterministic workflow orchestration CLI. It provides a
stable command contract (`fmt`, `lint`, `build`, `test`, `check`, etc.) that maps to
stack-specific toolchain invocations (Rust via cargo, Node via npm). The goal is
local/CI parity: the same commands run identically on a developer's machine and in
GitHub Actions.

**Current status**: v0.2.0, stable container-orchestrated CLI. The core platform supports
parse, config validates, extensions register, and processes spawn. There are known
architectural debts tracked in `docs/reference/v0.1.0-critical-review.md`.

## Workspace Layout

```
devflow/
  Cargo.toml                    # Workspace root — all shared deps here
  devflow.toml                  # Project's own devflow config (dogfooding)
  Makefile                      # Thin wrappers around `cargo run -p devflow-cli --`
  crates/
    devflow-core/               # Stack-agnostic core: command model, config, extensions, runtime
    devflow-cli/                # Binary crate (`dwf`): CLI parsing, dispatch, executor
    devflow-policy/             # Policy expansion: check:pr → [fmt:check, lint:static, ...]
    devflow-gh/                 # GitHub Actions workflow rendering and validation
    devflow-ext-rust/           # Rust extension: capability list (no execution logic yet)
    devflow-ext-node/           # Node extension: capability list (no execution logic yet)
  docs/                         # MyST documentation site
    myst.yml                    # MyST config
    toc.yml                     # Table of contents — maps to docs site structure
    index.md                    # Docs landing page
    developer-guide/            # Developer docs, architecture, ADRs, roadmap
    reference/                  # Critical review, brainstorms, decision records
  .github/workflows/ci.yml     # Generated by `dwf ci:generate` — do not hand-edit
```

## Crate Responsibilities

### devflow-core (`crates/devflow-core/`)

Stack-agnostic library. Must never import stack-specific logic or toolchain names.

| Module | Purpose |
|---|---|
| `command.rs` | `PrimaryCommand` enum (9 variants), `CommandRef` struct (primary + optional selector), `FromStr` parsing of `"test:unit"` syntax |
| `config.rs` | `DevflowConfig` loaded from TOML. Uses `#[serde(deny_unknown_fields)]`. `TargetsConfig` uses `HashMap<String, Vec<String>>` via `#[serde(flatten)]` for dynamic profiles. `validate()` checks stack names and command grammar in targets. |
| `extension.rs` | `ExtensionRegistry` discovers extensions from config. `ensure_can_run()` validates a command against capabilities. `validate_target_support()` checks all target profiles at startup. `builtin_capabilities()` calls into `devflow-ext-rust`/`devflow-ext-node`. |
| `runtime.rs` | `RuntimeProfile` enum: `Container`, `Host`, `Auto` (default). |

Key types re-exported from `lib.rs`: `CommandRef`, `PrimaryCommand`, `DevflowConfig`,
`ExtensionSource`, `TargetsConfig`, `ExtensionDescriptor`, `ExtensionRegistry`,
`RuntimeProfile`.

### devflow-cli (`crates/devflow-cli/`)

Binary crate producing the `dwf` executable.

| Module | Purpose |
|---|---|
| `main.rs` | Clap CLI parser. Merges `dwf test unit` → `test:unit`. Loads config, discovers extensions, validates targets, dispatches to `execute()`. Special handling for `check:*` (policy expansion), `ci:generate`, `ci:check`, `ci:plan`. |
| `executor.rs` | **The actual execution engine.** Resolves stacks from config, checks manifest presence (`Cargo.toml`/`package.json`), maps commands to toolchain argv, spawns processes via `std::process::Command`. Contains `map_rust()` and `map_node()` with hardcoded argv vectors. |

CLI flags: `--config <path>` (default: `devflow.toml`), `--stdout` (print CI workflow
instead of writing), `--ci-output <path>` (default: `.github/workflows/ci.yml`).

### devflow-policy (`crates/devflow-policy/`)

Single public function: `resolve_policy_commands(cfg, selector) -> Vec<CommandRef>`.
Looks up `cfg.targets.profiles[selector]` and parses each entry into a `CommandRef`.

### devflow-gh (`crates/devflow-gh/`)

Two public functions:
- `render_workflow(cfg)` — generates GitHub Actions YAML with prep/build/parallel-check
  jobs derived from the `pr` target profile.
- `check_workflow(cfg, workflow_str)` — validates a workflow string contains required
  jobs and command invocations.

Helper: `sanitize_job_name()` converts `fmt:check` → `fmt_check` for valid YAML keys.

### devflow-ext-rust / devflow-ext-node

Each exports `default_capabilities() -> &'static [&'static str]`. These are used as
fallback capability lists when `devflow.toml` doesn't explicitly declare capabilities
for a builtin extension.

**Important**: These crates do NOT contain execution logic. Command-to-toolchain mapping
currently lives in `devflow-cli/src/executor.rs`. This is a known architectural debt —
see critical review finding 3.1.

## Command Model

### Primary Commands

`setup`, `fmt`, `lint`, `build`, `test`, `package`, `check`, `release`, `ci`

### Selectors

Commands accept an optional selector via colon syntax: `test:unit`, `fmt:check`, `ci:generate`.

Two CLI syntaxes are equivalent: `dwf test:unit` and `dwf test unit`.

### Default Selectors

When a primary command is invoked without a selector, `executor.rs` applies defaults:

| Primary | Default selector | Effect |
|---|---|---|
| `setup` | `doctor` | Runs `cargo --version` / `npm --version` |
| `fmt` | `check` | Non-mutating format check |
| `lint` | `static` | Static analysis |
| `build` | `debug` | Debug build |
| `test` | `unit` | Unit tests only |
| `package` | `artifact` | Build release artifact |
| `check` | `pr` | PR gate profile |
| `release` | `candidate` | Release candidate build |
| `ci` | `check` | CI workflow validation |

### Policy Composition

`check:pr` expands to the command list in `[targets] pr = [...]`. The policy resolver
iterates the list and the executor runs each command sequentially.

## Configuration (`devflow.toml`)

### Current Accepted Schema

```toml
[project]
name = "example"           # Required
stack = ["rust"]            # Required. Values: "rust", "node"

[runtime]                   # Optional, defaults to auto
profile = "auto"            # Values: "container", "host", "auto"

[targets]                   # Optional. Any key name is valid (dynamic profiles)
pr = ["fmt:check", "lint:static", "build:debug", "test:unit"]
main = ["fmt:check", "lint:static", "build:release", "test:unit", "test:smoke"]
staging = ["fmt:check", "build:release", "test:integration"]

[extensions.rust]           # Extension name is the key
source = "builtin"          # "builtin" or "path"
version = "^0.1"            # Optional, not enforced yet
api_version = 1             # Optional, must be 1 if set
required = true             # Optional, default false
capabilities = [            # Optional for builtins (falls back to crate defaults)
  "fmt:check", "fmt:fix", "lint:static",
  "build:debug", "build:release",
  "test:unit", "test:integration", "test:smoke",
  "package:artifact", "check", "release",
  "ci:generate", "ci:check", "setup"
]
```

### Validation Rules

- `#[serde(deny_unknown_fields)]` on `DevflowConfig`, `ProjectConfig`, `RuntimeConfig`,
  and `ExtensionConfig`. Unknown keys cause a hard parse error.
- `TargetsConfig` uses `#[serde(flatten)]` so any profile name is accepted.
- `validate()` rejects unknown stack names and unparseable command strings in targets.
- `ExtensionRegistry::validate_target_support()` checks every target command against
  extension capabilities at startup.

### Known Schema Gap

The architecture document (`docs/v0.1.0-architecture-and-design-review.md` Section 6)
shows `[container]` and `[cache]` sections. These are NOT implemented and will cause
parse failures due to `deny_unknown_fields`. Do not add them to config yet.

## Execution Flow

```
CLI parse → load devflow.toml → validate config → discover extensions
→ validate targets against extensions → parse command → dispatch:

  check:*  → policy resolver → iterate commands → executor::run() each
  ci:generate → render_workflow() → write file or stdout
  ci:check  → render_workflow() → check_workflow()
  ci:plan   → list profile keys
  other     → ensure_can_run() → executor::run()

executor::run():
  resolve stacks from config → for each stack:
    check manifest exists (Cargo.toml / package.json)
    apply default selector if none given
    map command to argv via map_rust() / map_node()
    spawn process via std::process::Command
    propagate exit code
```

## Building and Running

```bash
# Build everything
cargo build --workspace

# Run a command via the CLI
cargo run -p devflow-cli -- fmt:check
cargo run -p devflow-cli -- check:pr
cargo run -p devflow-cli -- ci:generate --stdout

# Run tests
cargo test --workspace

# Quick format check
cargo fmt --all -- --check

# Lint
cargo clippy --all-targets --all-features -- -D warnings
```

The binary name is `dwf`. After `cargo install --path crates/devflow-cli`, use
`dwf fmt:check` directly.

## Testing

### Current Test Locations

| Crate | Tests | Coverage |
|---|---|---|
| `devflow-core::command` | 3 | Command parsing, selector extraction, unknown primary rejection |
| `devflow-core::config` | 2 | Unknown top-level key rejection, unknown project key rejection |
| `devflow-core::extension` | 2 | Supported target validation, unsupported target rejection |
| `devflow-policy` | 1 | PR profile resolution |
| `devflow-gh` | 3 | Render topology, rendered output self-validation, missing job detection |
| `devflow-cli::executor` | 0 | **No tests — critical gap** |

### Testing Conventions

- Tests live in `#[cfg(test)] mod tests` at the bottom of each source file.
- Use inline TOML fixtures via `toml::from_str()` for config tests.
- Name tests descriptively: `rejects_unknown_top_level_key`, `validates_supported_target_commands`.
- The `executor.rs` functions `map_rust()`, `map_node()`, `with_default_selector()`, and
  `resolve_stacks()` are pure and should be unit-tested. Process spawning (`run_argv`)
  needs integration tests or mocking.

### Running Tests

```bash
cargo test --workspace           # All tests
cargo test -p devflow-core       # Core only
cargo test -p devflow-gh         # GH renderer only
```

## Rust Toolchain Mappings (executor.rs)

Current command-to-argv mappings for the Rust stack:

| Command | Argv |
|---|---|
| `setup:toolchain` | `rustup show` |
| `setup:deps` | `cargo fetch` |
| `setup:doctor` | `cargo --version` |
| `fmt:check` | `cargo fmt --all -- --check` |
| `fmt:fix` | `cargo fmt --all` |
| `lint:static` | `cargo clippy --all-targets --all-features -- -D warnings` |
| `build:debug` | `cargo build` |
| `build:release` | `cargo build --release` |
| `test:unit` | `cargo test --lib --bins` |
| `test:integration` | `cargo test --tests` |
| `test:smoke` | `cargo test smoke` |
| `package:artifact` | `cargo build --release` |
| `release:candidate` | `cargo build --release` |

Node stack uses `npm ci`, `npm run <script>`, and `npm pack --dry-run`.

## Code Conventions

- **Error handling**: `anyhow::Result` for application errors, `thiserror` for typed errors
  in core (`CommandParseError`).
- **Serialization**: `serde::Deserialize` with `deny_unknown_fields` for strict config.
- **CLI**: `clap` with derive macros.
- **No `unwrap()` in non-test code.** Use `?`, `.context()`, or `bail!()`.
- **Module structure**: one file per concern in each crate's `src/`.
- Public types are re-exported from `lib.rs` for clean external API.
- Tests at bottom of file in `#[cfg(test)] mod tests`.

## Documentation Structure

Documentation uses [MyST Markdown](https://mystmd.org/) and is configured in `docs/myst.yml`
and `docs/toc.yml`.

```
docs/
  index.md                          # Landing page
  glossary.md                       # Terms: Canonical Command, Extension, Fingerprint, Parity
  reference.md                      # Reference section index
  user-guide/                       # End-user docs (installation, commands, config, CI)
  developer-guide/
    01-getting-started/             # Quickstart, contributing
    02-design/                      # Architecture, command model, extensions, ADRs
    03-development/                 # Workflow, local dev, coding standards, dogfooding
    04-infrastructure/              # CI overview
    05-operations/                  # Troubleshooting
    06-roadmap/                     # Migration decisions, implementation plans, critical review
    07-resources/                   # External references
```

Key architecture docs:
- `docs/developer-guide/02-design/architecture.md` — Canonical architecture baseline
- `docs/developer-guide/06-roadmap/v0.1.0-critical-review.md` — Active review with open findings
- `docs/developer-guide/06-roadmap/v0.1.0-implementation-execution-plan.md` — Phased delivery plan

Architecture docs are also available at the `docs/reference/` path (both locations may
exist due to doc restructuring).

## Known Issues and Open Decisions

These are tracked in `docs/reference/v0.1.0-critical-review.md` (revision 2).

### Critical

1. **Command mapping is in the wrong layer.** `map_rust()` and `map_node()` live in
   `devflow-cli/src/executor.rs` but should be in the extension crates per the
   architecture. Adding a new stack requires modifying the CLI, not writing an extension.

2. **Architecture doc schema shows `[container]` and `[cache]` sections** that the parser
   rejects with `deny_unknown_fields`. The documented schema is a guaranteed failure path.

### Major

3. **`ci:check` validates rendered output, not the committed file.** It should read
   `.github/workflows/ci.yml` from disk and compare against config expectations.

4. **`test:integration` re-runs unit tests.** `cargo test --tests` includes lib and bin
   test targets. Should use `cargo test --test '*'` or nextest for proper isolation.

5. **Generated CI has no `dwf` install step.** The workflow references `dwf` but does
   not install it.

6. **`executor.rs` has zero tests.** The most critical module is completely untested.

### Minor

7. `devflow.toml` declares `stack = ["rust", "node"]` but there is no `package.json`.
8. `stack_is_applicable()` uses relative paths — no project root resolution.
9. Node stack hardcodes `npm` — no `pnpm`/`yarn` detection.
10. Bare `setup` defaults to `setup:doctor` (version check), not environment setup.
11. Argv vectors are `&'static str` — no config-driven overrides or extra flags.
12. Bare `check` silently defaults to `check:pr`.
13. Legacy `kroki-rs` naming persists in `v0.1.0-ci-container-redesign.md`.

## Dependency Graph

```
devflow-cli
  ├── devflow-core
  │     ├── devflow-ext-rust   (builtin capabilities)
  │     └── devflow-ext-node   (builtin capabilities)
  ├── devflow-policy
  │     └── devflow-core
  └── devflow-gh
        └── devflow-core
```

Shared workspace dependencies: `anyhow`, `clap` (derive), `serde` (derive), `toml`, `thiserror`.

## Guidelines for Making Changes

### Adding a New Primary Command

1. Add variant to `PrimaryCommand` enum in `crates/devflow-core/src/command.rs`.
2. Add `as_str()` match arm and `FromStr` match arm in the same file.
3. Add default selector in `with_default_selector()` in `crates/devflow-cli/src/executor.rs`.
4. Add toolchain mappings in `map_rust()` and/or `map_node()` in `executor.rs`.
5. Add capability strings in `devflow-ext-rust/src/lib.rs` and/or `devflow-ext-node/src/lib.rs`.
6. Add tests for the new command in `command.rs`.

### Adding a New Selector to an Existing Command

1. Add match arm in `map_rust()` and/or `map_node()` in `executor.rs`.
2. Add capability string in the relevant extension crate's `default_capabilities()`.
3. Update `devflow.toml` capabilities list if applicable.

### Adding a New Target Profile

No code changes needed. Add the profile to `[targets]` in `devflow.toml`:

```toml
[targets]
hotfix = ["fmt:check", "build:release", "test:unit"]
```

Then use: `dwf check:hotfix`.

### Adding a New Stack

This is a significant change due to the architecture issue (finding 3.1):

1. Create `crates/devflow-ext-<stack>/` with `default_capabilities()`.
2. Add workspace member in root `Cargo.toml`.
3. Add dependency in `devflow-core/Cargo.toml`.
4. Add match arm in `builtin_capabilities()` in `extension.rs`.
5. Add stack name to validation whitelist in `config.rs` `validate()`.
6. Add `Stack` variant and `map_<stack>()` in `executor.rs`.
7. Add manifest detection in `stack_is_applicable()` in `executor.rs`.

### Modifying Configuration Schema

1. Edit structs in `crates/devflow-core/src/config.rs`.
2. Remember: `deny_unknown_fields` is active on most structs. New fields need struct changes.
3. `TargetsConfig` uses `#[serde(flatten)]` so new profile names work automatically.
4. Add validation in `DevflowConfig::validate()` if the field has constraints.
5. Update `devflow.toml` and architecture doc to match.
6. Add deserialization tests for both valid and invalid inputs.

### Writing Tests

- Place tests in `#[cfg(test)] mod tests` at bottom of the file being tested.
- Use `toml::from_str()` for config fixtures — keep them minimal.
- Test both success and failure paths. Name failure tests `rejects_*`.
- Pure functions (`map_rust`, `with_default_selector`) should have exhaustive unit tests.
- For process-spawning code, prefer integration tests or extract the pure logic.

## Commit and PR Conventions

- Ensure `cargo fmt --all -- --check` passes.
- Ensure `cargo clippy --all-targets --all-features -- -D warnings` passes.
- Ensure `cargo test --workspace` passes.
- Keep commits focused. One concern per commit.
- The generated `.github/workflows/ci.yml` should be regenerated via
  `cargo run -p devflow-cli -- ci:generate` if target profiles change.
