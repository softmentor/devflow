{"version":"1","records":[{"hierarchy":{"lvl1":"Contributing"},"type":"lvl1","url":"/contributing","position":0},{"hierarchy":{"lvl1":"Contributing"},"content":"Create focused PRs by capability slice.\n\nKeep docs and code aligned in the same change.\n\nAdd tests for command parsing, policy resolution, and CI generation changes.","type":"content","url":"/contributing","position":1},{"hierarchy":{"lvl1":"Quickstart"},"type":"lvl1","url":"/quickstart","position":0},{"hierarchy":{"lvl1":"Quickstart"},"content":"This section is for contributors who want to run and modify Devflow source code.\nFor now, use direct Cargo commands as the primary development path (dogfooding is phased later).","type":"content","url":"/quickstart","position":1},{"hierarchy":{"lvl1":"Quickstart","lvl2":"Prerequisites"},"type":"lvl2","url":"/quickstart#prerequisites","position":2},{"hierarchy":{"lvl1":"Quickstart","lvl2":"Prerequisites"},"content":"Git\n\nRust toolchain (cargo, rustc)","type":"content","url":"/quickstart#prerequisites","position":3},{"hierarchy":{"lvl1":"Quickstart","lvl2":"Step-by-Step"},"type":"lvl2","url":"/quickstart#step-by-step","position":4},{"hierarchy":{"lvl1":"Quickstart","lvl2":"Step-by-Step"},"content":"Clone repository:git clone https://github.com/softmentor/devflow.git\ncd devflow\n\nBuild and validate:cargo fmt\ncargo check --offline\ncargo test --offline\n\nRun core workflow commands from source:cargo run -p devflow-cli -- check:pr\ncargo run -p devflow-cli -- ci:generate\ncargo run -p devflow-cli -- ci:check","type":"content","url":"/quickstart#step-by-step","position":5},{"hierarchy":{"lvl1":"Quickstart","lvl2":"Crate Overview"},"type":"lvl2","url":"/quickstart#crate-overview","position":6},{"hierarchy":{"lvl1":"Quickstart","lvl2":"Crate Overview"},"content":"devflow-core: canonical command model, config parsing/validation, extension registry.\n\ndevflow-cli: executable entrypoint (dwf) and runtime command dispatch.\n\ndevflow-policy: profile expansion for check:<profile>.\n\ndevflow-gh: CI workflow generation and validation logic.\n\ndevflow-ext-rust: Rust extension implementing the Extension trait for canonical command mapping.\n\ndevflow-ext-node: Node extension implementing the Extension trait for canonical command mapping.","type":"content","url":"/quickstart#crate-overview","position":7},{"hierarchy":{"lvl1":"ADR-0001 Canonical Command Contract"},"type":"lvl1","url":"/adr-0001-command-contract","position":0},{"hierarchy":{"lvl1":"ADR-0001 Canonical Command Contract"},"content":"","type":"content","url":"/adr-0001-command-contract","position":1},{"hierarchy":{"lvl1":"ADR-0001 Canonical Command Contract","lvl2":"Status"},"type":"lvl2","url":"/adr-0001-command-contract#status","position":2},{"hierarchy":{"lvl1":"ADR-0001 Canonical Command Contract","lvl2":"Status"},"content":"Accepted","type":"content","url":"/adr-0001-command-contract#status","position":3},{"hierarchy":{"lvl1":"ADR-0001 Canonical Command Contract","lvl2":"Decision"},"type":"lvl2","url":"/adr-0001-command-contract#decision","position":4},{"hierarchy":{"lvl1":"ADR-0001 Canonical Command Contract","lvl2":"Decision"},"content":"Adopt primary commands with selector-based specialization (primary:selector).","type":"content","url":"/adr-0001-command-contract#decision","position":5},{"hierarchy":{"lvl1":"ADR-0001 Canonical Command Contract","lvl2":"Consequences"},"type":"lvl2","url":"/adr-0001-command-contract#consequences","position":6},{"hierarchy":{"lvl1":"ADR-0001 Canonical Command Contract","lvl2":"Consequences"},"content":"Stable top-level UX across stacks.\n\nCommand expansion can evolve by selector and extension capability.","type":"content","url":"/adr-0001-command-contract#consequences","position":7},{"hierarchy":{"lvl1":"ADR-0002 Cache Strategy Across Host, Container, and CI"},"type":"lvl1","url":"/adr-0002-cache-strategy","position":0},{"hierarchy":{"lvl1":"ADR-0002 Cache Strategy Across Host, Container, and CI"},"content":"","type":"content","url":"/adr-0002-cache-strategy","position":1},{"hierarchy":{"lvl1":"ADR-0002 Cache Strategy Across Host, Container, and CI","lvl2":"Status"},"type":"lvl2","url":"/adr-0002-cache-strategy#status","position":2},{"hierarchy":{"lvl1":"ADR-0002 Cache Strategy Across Host, Container, and CI","lvl2":"Status"},"content":"Accepted","type":"content","url":"/adr-0002-cache-strategy#status","position":3},{"hierarchy":{"lvl1":"ADR-0002 Cache Strategy Across Host, Container, and CI","lvl2":"Decision"},"type":"lvl2","url":"/adr-0002-cache-strategy#decision","position":4},{"hierarchy":{"lvl1":"ADR-0002 Cache Strategy Across Host, Container, and CI","lvl2":"Decision"},"content":"Adopt profile-aware cache partitioning where cache keys and directories are isolated by runtime profile (host vs container) and environment dimensions (os, arch, toolchain lock).","type":"content","url":"/adr-0002-cache-strategy#decision","position":5},{"hierarchy":{"lvl1":"ADR-0002 Cache Strategy Across Host, Container, and CI","lvl2":"Rationale"},"type":"lvl2","url":"/adr-0002-cache-strategy#rationale","position":6},{"hierarchy":{"lvl1":"ADR-0002 Cache Strategy Across Host, Container, and CI","lvl2":"Rationale"},"content":"Prevent artifact contamination across heterogeneous runtimes.\n\nKeep cache as optimization only; correctness must not rely on hits.\n\nAlign local and CI cache behavior with explicit boundaries.","type":"content","url":"/adr-0002-cache-strategy#rationale","position":7},{"hierarchy":{"lvl1":"ADR-0002 Cache Strategy Across Host, Container, and CI","lvl2":"Consequences"},"type":"lvl2","url":"/adr-0002-cache-strategy#consequences","position":8},{"hierarchy":{"lvl1":"ADR-0002 Cache Strategy Across Host, Container, and CI","lvl2":"Consequences"},"content":"More cache directories/keys to manage.\n\nHigher storage usage, but significantly lower risk of false positives/negatives in builds and tests.","type":"content","url":"/adr-0002-cache-strategy#consequences","position":9},{"hierarchy":{"lvl1":"ADR-0003 Dynamic Extension Wiring and Subprocess Execution"},"type":"lvl1","url":"/adr-0003-dynamic-extension-wiring","position":0},{"hierarchy":{"lvl1":"ADR-0003 Dynamic Extension Wiring and Subprocess Execution"},"content":"","type":"content","url":"/adr-0003-dynamic-extension-wiring","position":1},{"hierarchy":{"lvl1":"ADR-0003 Dynamic Extension Wiring and Subprocess Execution","lvl2":"ADR-0003: Dynamic Extension Wiring and Subprocess Execution"},"type":"lvl2","url":"/adr-0003-dynamic-extension-wiring#adr-0003-dynamic-extension-wiring-and-subprocess-execution","position":2},{"hierarchy":{"lvl1":"ADR-0003 Dynamic Extension Wiring and Subprocess Execution","lvl2":"ADR-0003: Dynamic Extension Wiring and Subprocess Execution"},"content":"","type":"content","url":"/adr-0003-dynamic-extension-wiring#adr-0003-dynamic-extension-wiring-and-subprocess-execution","position":3},{"hierarchy":{"lvl1":"ADR-0003 Dynamic Extension Wiring and Subprocess Execution","lvl3":"Context","lvl2":"ADR-0003: Dynamic Extension Wiring and Subprocess Execution"},"type":"lvl3","url":"/adr-0003-dynamic-extension-wiring#context","position":4},{"hierarchy":{"lvl1":"ADR-0003 Dynamic Extension Wiring and Subprocess Execution","lvl3":"Context","lvl2":"ADR-0003: Dynamic Extension Wiring and Subprocess Execution"},"content":"Devflow needs to support multiple language stacks (rust, node, python, etc.) without bloating the core CLI binary with language-specific compilation or logic.\nInitially, the devflow-core library directly depended on extension crates using hardcoded dispatch tables, which violated the stack-agnostic boundary of the core engine and prevented external developers from writing custom project extensions.","type":"content","url":"/adr-0003-dynamic-extension-wiring#context","position":5},{"hierarchy":{"lvl1":"ADR-0003 Dynamic Extension Wiring and Subprocess Execution","lvl3":"Decision","lvl2":"ADR-0003: Dynamic Extension Wiring and Subprocess Execution"},"type":"lvl3","url":"/adr-0003-dynamic-extension-wiring#decision","position":6},{"hierarchy":{"lvl1":"ADR-0003 Dynamic Extension Wiring and Subprocess Execution","lvl3":"Decision","lvl2":"ADR-0003: Dynamic Extension Wiring and Subprocess Execution"},"content":"We have decided to formalize an Extension trait and introduce dynamic runtime discovery.\n\nExtension Trait: All extensions implement an Extension trait offering name(), capabilities(), and build_action(). devflow-core completely drops dependencies on specific stack implementations (devflow-ext-rust, devflow-ext-node).\n\nDynamic Boot Wiring: At boot, devflow-cli dynamically instantiates extensions and places them into an ExtensionRegistry.\n\nSubprocess Delegation: For extensions not built into the CLI, Devflow will discover binaries in $PATH prefixed with devflow-ext-. It will probe these binaries by executing them with --discover, which returns a JSON array of supported capabilities.\n\nExecution Protocol: To execute a targeted command, the Core serialization engine pipes a standard JSON CommandRef to the external binary via standard IO stdin (using --build-action). The binary returns an ExecutionAction (program and arguments) as JSON over stdout.","type":"content","url":"/adr-0003-dynamic-extension-wiring#decision","position":7},{"hierarchy":{"lvl1":"ADR-0003 Dynamic Extension Wiring and Subprocess Execution","lvl3":"Consequences","lvl2":"ADR-0003: Dynamic Extension Wiring and Subprocess Execution"},"type":"lvl3","url":"/adr-0003-dynamic-extension-wiring#consequences","position":8},{"hierarchy":{"lvl1":"ADR-0003 Dynamic Extension Wiring and Subprocess Execution","lvl3":"Consequences","lvl2":"ADR-0003: Dynamic Extension Wiring and Subprocess Execution"},"content":"","type":"content","url":"/adr-0003-dynamic-extension-wiring#consequences","position":9},{"hierarchy":{"lvl1":"ADR-0003 Dynamic Extension Wiring and Subprocess Execution","lvl4":"Positive","lvl3":"Consequences","lvl2":"ADR-0003: Dynamic Extension Wiring and Subprocess Execution"},"type":"lvl4","url":"/adr-0003-dynamic-extension-wiring#positive","position":10},{"hierarchy":{"lvl1":"ADR-0003 Dynamic Extension Wiring and Subprocess Execution","lvl4":"Positive","lvl3":"Consequences","lvl2":"ADR-0003: Dynamic Extension Wiring and Subprocess Execution"},"content":"devflow-core is purely an orchestration engine, completely uncoupled from language specifics.\n\nTeams can write new Devflow extensions in any language (Go, Python, Bash) simply by writing a binary that responds to --discover and --build-action with JSON.\n\nCommand mapping logic natively resides inside the specific technology stack crate instead of sprawling match statements inside devflow-cli/src/executor.rs.","type":"content","url":"/adr-0003-dynamic-extension-wiring#positive","position":11},{"hierarchy":{"lvl1":"ADR-0003 Dynamic Extension Wiring and Subprocess Execution","lvl4":"Negative","lvl3":"Consequences","lvl2":"ADR-0003: Dynamic Extension Wiring and Subprocess Execution"},"type":"lvl4","url":"/adr-0003-dynamic-extension-wiring#negative","position":12},{"hierarchy":{"lvl1":"ADR-0003 Dynamic Extension Wiring and Subprocess Execution","lvl4":"Negative","lvl3":"Consequences","lvl2":"ADR-0003: Dynamic Extension Wiring and Subprocess Execution"},"content":"Serialization overhead when passing Command contexts to sub-processes.\n\nReliance on $PATH configurations means execution environments must be properly curated for subprocess discovery to succeed.","type":"content","url":"/adr-0003-dynamic-extension-wiring#negative","position":13},{"hierarchy":{"lvl1":"ADR Index"},"type":"lvl1","url":"/index-1","position":0},{"hierarchy":{"lvl1":"ADR Index"},"content":"","type":"content","url":"/index-1","position":1},{"hierarchy":{"lvl1":"ADR Index","lvl2":"Architecture Decision Records"},"type":"lvl2","url":"/index-1#architecture-decision-records","position":2},{"hierarchy":{"lvl1":"ADR Index","lvl2":"Architecture Decision Records"},"content":"ADR-0001: Canonical Command Contract\n\nADR-0002: Cache Strategy Across Host, Container, and CI\n\nADR-0003: Dynamic Extension Wiring and Subprocess Execution","type":"content","url":"/index-1#architecture-decision-records","position":3},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline"},"type":"lvl1","url":"/architecture","position":0},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline"},"content":"","type":"content","url":"/architecture","position":1},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"1. Objective"},"type":"lvl2","url":"/architecture#id-1-objective","position":2},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"1. Objective"},"content":"Define one implementation-ready baseline for devflow so we can:\n\nAgree architecture boundaries.\n\nLock design details and non-goals.\n\nRun a review gate before implementation starts.\n\nThis document consolidates the existing brainstorm and decision docs into one practical plan.","type":"content","url":"/architecture#id-1-objective","position":3},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"2. Scope and Non-Goals"},"type":"lvl2","url":"/architecture#id-2-scope-and-non-goals","position":4},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"2. Scope and Non-Goals"},"content":"In scope for v0.1.0:\n\nStandalone devflow CLI (devflow, alias dwf).\n\nCanonical command graph and deterministic execution model.\n\nRust-first extension with Node baseline extension.\n\nContainer and cache strategy for local and CI parity.\n\nGitHub Actions rendering and required-check contracts.\n\nOut of scope for v0.1.0:\n\nFull multi-format serialization matrix for all paths.\n\nBroad plugin marketplace/runtime distribution.\n\nAdvanced multi-provider CI backends beyond GitHub Actions.","type":"content","url":"/architecture#id-2-scope-and-non-goals","position":5},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"3. Architecture Overview"},"type":"lvl2","url":"/architecture#id-3-architecture-overview","position":6},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"3. Architecture Overview"},"content":"flowchart LR\n    subgraph UX[\"Developer Experience\"]\n        CLI[\"devflow-cli\"]\n        CFG[\"devflow.toml\"]\n    end\n\n    subgraph ORCH[\"Orchestration Layer\"]\n        CORE[\"devflow-core DAG Executor\"]\n        POLICY[\"devflow-policy\"]\n        GH[\"devflow-gh Renderer\"]\n    end\n\n    subgraph EXT[\"Extension Layer\"]\n        RUST[\"devflow-ext-rust\"]\n        NODE[\"devflow-ext-node\"]\n    end\n\n    subgraph RUN[\"Execution Runtime\"]\n        CONT[\"Container Profile\"]\n        HOST[\"Host Profile\"]\n        CACHE[\"Cache Root\"]\n    end\n\n    CLI --> CORE\n    CFG --> CLI\n    CFG --> CORE\n    GH --> CORE\n    CORE --> POLICY\n    CORE --> RUST\n    CORE --> NODE\n    RUST --> CONT\n    NODE --> CONT\n    RUST --> HOST\n    NODE --> HOST\n    CONT --> CACHE\n    HOST --> CACHE\n\nArchitecture constraints:\n\ndevflow-core is stack-agnostic.\n\nStack-specific logic lives in devflow-ext-*.\n\nCI YAML orchestrates only; command semantics stay in devflow.","type":"content","url":"/architecture#id-3-architecture-overview","position":7},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"4. Workspace Structure (Target)"},"type":"lvl2","url":"/architecture#id-4-workspace-structure-target","position":8},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"4. Workspace Structure (Target)"},"content":"devflow/\n  Cargo.toml\n  crates/\n    devflow-core/\n    devflow-cli/\n    devflow-policy/\n    devflow-gh/\n    devflow-ext-rust/\n    devflow-ext-node/\n  examples/\n    rust-lib/\n    node-ts/\n  docs/\n\nOwnership boundaries:\n\ndevflow-core: task graph, execution engine, cache key coordination.\n\ndevflow-cli: UX, argument parsing, command dispatch.\n\ndevflow-policy: gate profiles, required check contracts.\n\ndevflow-gh: workflow generation and validation.\n\ndevflow-ext-*: command-to-toolchain translation.","type":"content","url":"/architecture#id-4-workspace-structure-target","position":9},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"5. Canonical Command Contract"},"type":"lvl2","url":"/architecture#id-5-canonical-command-contract","position":10},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"5. Canonical Command Contract"},"content":"","type":"content","url":"/architecture#id-5-canonical-command-contract","position":11},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Command hierarchy for developer experience","lvl2":"5. Canonical Command Contract"},"type":"lvl3","url":"/architecture#command-hierarchy-for-developer-experience","position":12},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Command hierarchy for developer experience","lvl2":"5. Canonical Command Contract"},"content":"Based on common workflows across Rust, Node, Python, JVM, and polyglot repos, commands work best when split into two levels:\n\nPrimary commands: stable verbs developers run daily.\n\nSecondary commands: scoped variants selected by policy, profile, or explicit command target.\n\nFirst-principles rules used:\n\nKeep top-level verbs small and stable.\n\nMake mutating vs non-mutating behavior explicit (for example fmt:fix vs fmt:check).\n\nPush environment-specific behavior to selectors, not new top-level commands.\n\nModel policy gates as composition (check:*), not as a separate legacy workflow command.","type":"content","url":"/architecture#command-hierarchy-for-developer-experience","position":13},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Primary commands (v0.1.0 baseline)","lvl2":"5. Canonical Command Contract"},"type":"lvl3","url":"/architecture#primary-commands-v0-1-0-baseline","position":14},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Primary commands (v0.1.0 baseline)","lvl2":"5. Canonical Command Contract"},"content":"Primary command\n\nPurpose\n\nTypical effect\n\nsetup\n\nPrepare local/CI prerequisites.\n\nInstalls/syncs toolchains, dependencies, and optional container prerequisites.\n\nfmt\n\nFormat source according to project rules.\n\nUses selectors such as fmt:check (read-only) and fmt:fix (mutating).\n\nlint\n\nRun static and policy checks.\n\nReports code quality and policy violations.\n\nbuild\n\nCompile/package artifacts.\n\nProduces build outputs for current profile.\n\ntest\n\nRun automated tests.\n\nExecutes selected test suites (test:unit, test:integration, etc.).\n\npackage\n\nAssemble distributable outputs.\n\nProduces artifacts/images/bundles and metadata.\n\ncheck\n\nExecute policy-defined non-mutating gate.\n\nComposes selectors for contexts like check:pr, check:main, check:release.\n\nrelease\n\nExecute release orchestration steps.\n\nProduces release candidates, publish steps, and release metadata.\n\nci\n\nManage CI contract generation and validation.\n\nHandles selectors such as ci:generate, ci:check, and ci:plan.","type":"content","url":"/architecture#primary-commands-v0-1-0-baseline","position":15},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Secondary command families","lvl2":"5. Canonical Command Contract"},"type":"lvl3","url":"/architecture#secondary-command-families","position":16},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Secondary command families","lvl2":"5. Canonical Command Contract"},"content":"setup: setup:toolchain, setup:deps, setup:container, setup:doctor\n\nfmt: fmt:check, fmt:fix\n\nlint: lint:static, lint:security, lint:policy, lint:fix\n\nbuild: build:debug, build:release\n\ntest: test:unit, test:integration, test:contract, test:e2e, test:smoke, test:load\n\npackage: package:artifact, package:image, package:sbom\n\ncheck: check:pr, check:main, check:release\n\nrelease: release:candidate, release:publish, release:notes\n\nci: ci:generate, ci:check, ci:plan\n\nSecondary commands may be exposed as:\n\nexplicit subcommands (for example dwf test unit mapped to test:unit), or\n\nprofile aliases in config (for example targets.pr = [\"fmt:check\", \"lint:static\", \"build:debug\", \"test:unit\", \"test:integration\"]).","type":"content","url":"/architecture#secondary-command-families","position":17},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Command behavior rules","lvl2":"5. Canonical Command Contract"},"type":"lvl3","url":"/architecture#command-behavior-rules","position":18},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Command behavior rules","lvl2":"5. Canonical Command Contract"},"content":"Same command names across stacks.\n\nPrimary commands are contract-stable; secondary commands are extension-capability dependent.\n\nExtension maps canonical commands and secondary variants to stack-native operations.\n\ncheck is policy-driven composition of primary and secondary commands.","type":"content","url":"/architecture#command-behavior-rules","position":19},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Alternative considered","lvl2":"5. Canonical Command Contract"},"type":"lvl3","url":"/architecture#alternative-considered","position":20},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Alternative considered","lvl2":"5. Canonical Command Contract"},"content":"Alternative: many narrow top-level commands (unit-test, integration-test, security-scan, package, release-check).\nDecision: reject for v0.1.0 because it increases cognitive load and weakens cross-stack portability.","type":"content","url":"/architecture#alternative-considered","position":21},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"6. Configuration Contract (devflow.toml)"},"type":"lvl2","url":"/architecture#id-6-configuration-contract-devflow-toml","position":22},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"6. Configuration Contract (devflow.toml)"},"content":"Minimum schema for v0.1.0:[project]\nname = \"example\"\nstack = [\"rust\"]\n\n[container]\nimage = \"ghcr.io/org/repo-ci\"\nfingerprint_inputs = [\"Dockerfile\", \"Makefile\", \"src-scripts/**\", \"rust-toolchain.toml\"]\n\n[cache]\nroot = \".cache/devflow\"\nstrategy = \"layered\"\n\n[targets]\npr = [\"fmt:check\", \"lint:static\", \"build:debug\", \"test:unit\", \"test:integration\"]\nmain = [\"fmt:check\", \"lint:static\", \"build:release\", \"test:unit\", \"test:integration\", \"test:smoke\"]\nstaging = [\"fmt:check\", \"lint:static\", \"build:release\", \"test:unit\", \"test:integration\", \"test:smoke\", \"package:artifact\"]\n\nRules:\n\nUnknown keys fail validation.\n\nTarget profiles are dynamic map keys (for example pr, main, develop, staging, hotfix).\n\nMissing required fields fail fast with actionable diagnostics.\n\nDefaults exist for local bootstrap where safe.","type":"content","url":"/architecture#id-6-configuration-contract-devflow-toml","position":23},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"7. Execution and Runtime Design"},"type":"lvl2","url":"/architecture#id-7-execution-and-runtime-design","position":24},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"7. Execution and Runtime Design"},"content":"Execution model:\n\nLoad devflow.toml.\n\nResolve stack extensions.\n\nBuild command DAG.\n\nSelect runtime profile (container, host, or auto).\n\nResolve execution identity (container fingerprint or host toolchain fingerprint).\n\nResolve and restore cache layers.\n\nExecute task graph with deterministic ordering.\n\nEmit check status and artifacts.\n\nRuntime profile policy:\n\ncontainer: default for CI and recommended for reproducibility.\n\nhost: allowed when projects explicitly opt out of container-first execution.\n\nauto: use container when available, otherwise host with compatibility checks.\n\nHost compatibility checks (required in host and auto profiles):\n\ntoolchain version compliance (rust-toolchain.toml, Node version, etc.)\n\nrequired binary availability\n\nOS/arch support guardrails\n\nextension-declared prerequisites\n\nDeterminism constraints:\n\nExecution identity must include all declared fingerprint inputs and runtime profile.\n\nCache keys must include os, arch, toolchain lock dimensions.\n\nCorrectness must not depend on cache hits.","type":"content","url":"/architecture#id-7-execution-and-runtime-design","position":25},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"8. Container and Cache Design"},"type":"lvl2","url":"/architecture#id-8-container-and-cache-design","position":26},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"8. Container and Cache Design"},"content":"Canonical cache root:\n\nDEVFLOW_CACHE_ROOT (default .cache/devflow)\n\nSubdirectories:\n\nregistry/\n\ngit/\n\nsccache/\n\ntarget-ci/\n\nimage-tar/\n\nbuildx/\n\nPolicy:\n\nProject-scoped cache by default.\n\nKeep local and CI layout consistent.\n\nTreat cache as optimization only.\n\nAllow profile-specific cache partitioning (container vs host) to avoid artifact contamination.","type":"content","url":"/architecture#id-8-container-and-cache-design","position":27},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"9. CI Design Contract (GitHub Actions)"},"type":"lvl2","url":"/architecture#id-9-ci-design-contract-github-actions","position":28},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"9. CI Design Contract (GitHub Actions)"},"content":"Job topology:\n\nprep: fingerprint resolution and image selection.\n\nbuild: compile baseline once in CI container.\n\nfmt, lint, test-unit, test-integration, test-smoke (optional): parallel check jobs with clear status visibility.\n\nCI contract:\n\nCI uses dwf/Make entrypoints only.\n\nNo business logic in workflow YAML.\n\nRequired checks and branch policy generated from config.","type":"content","url":"/architecture#id-9-ci-design-contract-github-actions","position":29},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"10. Extension System Design"},"type":"lvl2","url":"/architecture#id-10-extension-system-design","position":30},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"10. Extension System Design"},"content":"Extension API requirements:\n\nImplement the Extension trait (name, capabilities, build_action).\n\nMap canonical commands to executable executable definitions (ExecutionAction).\n\nDecouple from core logic via dynamic registration in the ExtensionRegistry.","type":"content","url":"/architecture#id-10-extension-system-design","position":31},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Extension discovery model","lvl2":"10. Extension System Design"},"type":"lvl3","url":"/architecture#extension-discovery-model","position":32},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Extension discovery model","lvl2":"10. Extension System Design"},"content":"v0.1.0 supports two discovery sources:\n\nBuilt-in extensions linked with the binary.\n\nLocal project extensions declared by path in config.\n\nPost-v0.1.0 registry support (planned):\n\nnamed extension source (registry = \"ghcr|git|custom\")\n\nsigned metadata and integrity checks\n\nregistry index pinning for reproducibility","type":"content","url":"/architecture#extension-discovery-model","position":33},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Extension declaration (proposed)","lvl2":"10. Extension System Design"},"type":"lvl3","url":"/architecture#extension-declaration-proposed","position":34},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Extension declaration (proposed)","lvl2":"10. Extension System Design"},"content":"[extensions.rust]\nsource = \"builtin\"\nversion = \"^0.1\"\n\n[extensions.node]\nsource = \"builtin\"\nversion = \"^0.1\"\n\n[extensions.custom_lint]\nsource = \"path\"\npath = \"./tools/devflow-ext-custom-lint\"\nversion = \"0.1.0\"","type":"content","url":"/architecture#extension-declaration-proposed","position":35},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Versioning and compatibility checks","lvl2":"10. Extension System Design"},"type":"lvl3","url":"/architecture#versioning-and-compatibility-checks","position":36},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Versioning and compatibility checks","lvl2":"10. Extension System Design"},"content":"Extension API has an explicit api_version (for example 1).\n\nCore checks compatibility before loading:\n\nAPI compatibility: extension api_version == core.api_version\n\nsemantic version policy: extension version satisfies configured range\n\ncapability contract: required capabilities exist for selected command/profile\n\nIncompatible extension behavior:\n\nhard fail for required extensions\n\nwarning + skip for optional extensions","type":"content","url":"/architecture#versioning-and-compatibility-checks","position":37},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Extension loading lifecycle","lvl2":"10. Extension System Design"},"type":"lvl3","url":"/architecture#extension-loading-lifecycle","position":38},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Extension loading lifecycle","lvl2":"10. Extension System Design"},"content":"Discover configured extensions.\n\nResolve versions against lock/constraints.\n\nValidate checksums/signatures (when source supports it).\n\nRun compatibility checks.\n\nBuild command capability map.\n\nLoad execution adapter and run health probe.\n\nRegister into command dispatcher.","type":"content","url":"/architecture#extension-loading-lifecycle","position":39},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Compatibility lock file (proposed)","lvl2":"10. Extension System Design"},"type":"lvl3","url":"/architecture#compatibility-lock-file-proposed","position":40},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl3":"Compatibility lock file (proposed)","lvl2":"10. Extension System Design"},"content":"devflow.lock captures:\n\nresolved extension versions\n\nsource and integrity digest\n\nresolved capability map\n\nruntime profile constraints\n\nv0.1.0 extension sequence:\n\ndevflow-ext-rust (first class).\n\ndevflow-ext-node (baseline parity).\n\nDeferred:\n\nremote registry distribution and install workflows.","type":"content","url":"/architecture#compatibility-lock-file-proposed","position":41},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"11. Phase-Gated Delivery Plan"},"type":"lvl2","url":"/architecture#id-11-phase-gated-delivery-plan","position":42},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"11. Phase-Gated Delivery Plan"},"content":"Phase A0: governance and ADRs.\nPhase A1: core engine + command graph + container/cache contract.\nPhase A2: extension API with Rust and Node support.\nPhase A3: distribution and docs.\n\nMandatory phase gates:\n\nQuality gate: fmt:check, lint:static, build:debug/release, test:unit, test:integration (and test:smoke where required).\n\nArchitecture gate: command contract stability, extension API checks, CI/local parity audit.","type":"content","url":"/architecture#id-11-phase-gated-delivery-plan","position":43},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"12. Design Review Findings"},"type":"lvl2","url":"/architecture#id-12-design-review-findings","position":44},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"12. Design Review Findings"},"content":"Key strengths:\n\nClear separation between core orchestration and stack extensions.\n\nStable command surface for developers.\n\nDeterministic CI/local model with explicit cache contracts.\n\nKey risks:\n\nOver-abstraction too early in extension APIs.\n\nFingerprint input drift between code and docs.\n\nPolicy/YAML divergence if rendering contract is weakly enforced.\n\nRequired mitigations:\n\nKeep v0.1.0 API minimal and measured.\n\nAdd fingerprint conformance test.\n\nAdd CI rendering snapshot tests and policy validation checks.","type":"content","url":"/architecture#id-12-design-review-findings","position":45},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"13. Review Checklist (Pre-Implementation Gate)"},"type":"lvl2","url":"/architecture#id-13-review-checklist-pre-implementation-gate","position":46},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"13. Review Checklist (Pre-Implementation Gate)"},"content":"Architecture:\n\nCore crate has no stack-specific logic.\n\nExtension API is minimal and documented.\n\nCommand contract is finalized and versioned.\n\nRuntime:\n\nFingerprint inputs are single-sourced and test-covered.\n\nCache key dimensions are explicit and documented.\n\nContainer fallback behavior is defined.\n\nCI/Policy:\n\nWorkflow render output is deterministic.\n\nRequired checks align with target profiles.\n\nYAML contains orchestration only.\n\nDeveloper UX:\n\nError messages include clear next actions.\n\nLocal command names exactly match CI targets.\n\ndwf check behavior is documented and reproducible.\n\nPrimary and secondary command semantics are documented.\n\nExtensions:\n\nExtension discovery sources are explicitly configured.\n\nCompatibility checks are enforced before execution.\n\nRequired extension failures are deterministic and actionable.","type":"content","url":"/architecture#id-13-review-checklist-pre-implementation-gate","position":47},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"14. Decisions to Confirm Before Implementation"},"type":"lvl2","url":"/architecture#id-14-decisions-to-confirm-before-implementation","position":48},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"14. Decisions to Confirm Before Implementation"},"content":"Cache env var name: DEVFLOW_CACHE_ROOT.\n\nPR gate defaults: keep test:smoke required in PR or move to main only.\n\nRuntime profile default: container for all projects, or auto with host fallback by default.\n\nNode extension scope in v0.1.0: baseline (fmt/lint/test/build) or full parity including test:smoke.\n\nExtension discovery scope in v0.1.0: built-in only, or built-in + local-path extensions.\n\nWorkflow ownership: generated files committed to repo or generated on-demand in CI.","type":"content","url":"/architecture#id-14-decisions-to-confirm-before-implementation","position":49},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"15. Implementation Start Condition"},"type":"lvl2","url":"/architecture#id-15-implementation-start-condition","position":50},{"hierarchy":{"lvl1":"v0.1.0 Architecture and Design Review Baseline","lvl2":"15. Implementation Start Condition"},"content":"Implementation begins only when section 14 decisions are confirmed and section 13 checklist is approved.","type":"content","url":"/architecture#id-15-implementation-start-condition","position":51},{"hierarchy":{"lvl1":"Command Model"},"type":"lvl1","url":"/command-model","position":0},{"hierarchy":{"lvl1":"Command Model"},"content":"Devflow uses a two-level command system:\n\nPrimary command: stable top-level verb (test, check, ci).\n\nSelector: scoped behavior (test:unit, check:pr, ci:generate).\n\nThis model keeps UX stable while allowing extension-specific specialization.","type":"content","url":"/command-model","position":1},{"hierarchy":{"lvl1":"Extension Model"},"type":"lvl1","url":"/extensions","position":0},{"hierarchy":{"lvl1":"Extension Model"},"content":"Extension entries are declared in devflow.toml under [extensions.*].\n\nSupported sources:\n\nbuiltin: Extensions directly compiled and linked into the CLI.\n\npath: (Planned) Local extensions loaded via path.\n\nsubprocess: Binaries named devflow-ext-<stack> available in system $PATH that implement the standard JSON over stdio extension protocol.\n\nValidation includes:\n\nAPI version checks\n\ncapability coverage for target profiles\n\nJSON decode payload mapping for subprocesses","type":"content","url":"/extensions","position":1},{"hierarchy":{"lvl1":"Coding Standards"},"type":"lvl1","url":"/coding-standards","position":0},{"hierarchy":{"lvl1":"Coding Standards"},"content":"Keep command semantics explicit and deterministic.\n\nFail fast on config validation.\n\nAdd tests for policy and workflow-generation behavior.","type":"content","url":"/coding-standards","position":1},{"hierarchy":{"lvl1":"Dogfooding Strategy"},"type":"lvl1","url":"/dogfooding","position":0},{"hierarchy":{"lvl1":"Dogfooding Strategy"},"content":"Using Devflow to run Devflow itself is valuable, but it should be phased.","type":"content","url":"/dogfooding","position":1},{"hierarchy":{"lvl1":"Dogfooding Strategy","lvl2":"Benefits"},"type":"lvl2","url":"/dogfooding#benefits","position":2},{"hierarchy":{"lvl1":"Dogfooding Strategy","lvl2":"Benefits"},"content":"validates real-world workflow fit continuously\n\ncatches command and profile regressions early\n\nforces clear UX and documentation","type":"content","url":"/dogfooding#benefits","position":3},{"hierarchy":{"lvl1":"Dogfooding Strategy","lvl2":"Risks Before Stable Release"},"type":"lvl2","url":"/dogfooding#risks-before-stable-release","position":4},{"hierarchy":{"lvl1":"Dogfooding Strategy","lvl2":"Risks Before Stable Release"},"content":"bootstrap fragility (tool must build before it can orchestrate)\n\ncircular breakage (dwf regression can block all project checks)\n\nslower debugging if orchestration and product issues are mixed","type":"content","url":"/dogfooding#risks-before-stable-release","position":5},{"hierarchy":{"lvl1":"Dogfooding Strategy","lvl2":"Recommended Approach"},"type":"lvl2","url":"/dogfooding#recommended-approach","position":6},{"hierarchy":{"lvl1":"Dogfooding Strategy","lvl2":"Recommended Approach"},"content":"Keep direct cargo fallback commands documented and working.\n\nUse dwf for non-critical local checks first.\n\nGate CI with dwf only after command and config contracts are stable.\n\nMaintain a minimal emergency CI path (cargo check/test) during early releases.","type":"content","url":"/dogfooding#recommended-approach","position":7},{"hierarchy":{"lvl1":"Local Development"},"type":"lvl1","url":"/local-dev","position":0},{"hierarchy":{"lvl1":"Local Development"},"content":"Useful commands:\n\ncargo run -p devflow-cli -- test:unit\n\ncargo run -p devflow-cli -- ci:generate\n\ncargo run -p devflow-cli -- ci:check","type":"content","url":"/local-dev","position":1},{"hierarchy":{"lvl1":"Development Workflow"},"type":"lvl1","url":"/workflow","position":0},{"hierarchy":{"lvl1":"Development Workflow"},"content":"Recommended local sequence:cargo fmt\ncargo check --offline\ncargo test --offline\ncargo run -p devflow-cli -- check:pr","type":"content","url":"/workflow","position":1},{"hierarchy":{"lvl1":"Writing Custom Extensions"},"type":"lvl1","url":"/writing-extensions","position":0},{"hierarchy":{"lvl1":"Writing Custom Extensions"},"content":"Devflow allows you to write custom workflow extensions in any language. Because Devflow interacts with extensions using a simple JSON over standard I/O (often referred to as a “JSON-RPC” protocol via --discover and --build-action), you are not constrained to writing Rust code to extend the CLI.\n\nThis guide explains how external developers can write, debug, and test Devflow extensions locally.","type":"content","url":"/writing-extensions","position":1},{"hierarchy":{"lvl1":"Writing Custom Extensions","lvl2":"The Extension Protocol"},"type":"lvl2","url":"/writing-extensions#the-extension-protocol","position":2},{"hierarchy":{"lvl1":"Writing Custom Extensions","lvl2":"The Extension Protocol"},"content":"To create a Devflow extension, you need an executable script or binary whose name starts with a devflow-ext- prefix. Devflow uses this prefix to discover your logic.\n\nYour extension must handle two CLI flags:\n\n--discover: Announce what Devflow features you support.\n\n--build-action: Receive a parsed command and tell Devflow what to run.","type":"content","url":"/writing-extensions#the-extension-protocol","position":3},{"hierarchy":{"lvl1":"Writing Custom Extensions","lvl3":"Step 1: Handling --discover","lvl2":"The Extension Protocol"},"type":"lvl3","url":"/writing-extensions#step-1-handling-discover","position":4},{"hierarchy":{"lvl1":"Writing Custom Extensions","lvl3":"Step 1: Handling --discover","lvl2":"The Extension Protocol"},"content":"When devflow runs or boots up, it looks for extension binaries in your $PATH and queries them using:devflow-ext-myext --discover\n\nYour script must output a JSON array of supported capabilities to stdout and exit with code 0.\n\nExample Python implementation:import sys\nimport json\n\nif \"--discover\" in sys.argv:\n    # Say that we support \"test\" and \"fmt\"\n    print(json.dumps([\"test\", \"fmt\", \"test:lint\"]))\n    sys.exit(0)","type":"content","url":"/writing-extensions#step-1-handling-discover","position":5},{"hierarchy":{"lvl1":"Writing Custom Extensions","lvl3":"Step 2: Handling --build-action","lvl2":"The Extension Protocol"},"type":"lvl3","url":"/writing-extensions#step-2-handling-build-action","position":6},{"hierarchy":{"lvl1":"Writing Custom Extensions","lvl3":"Step 2: Handling --build-action","lvl2":"The Extension Protocol"},"content":"When a user runs a supported command (e.g., devflow test), Devflow matches the \"test\" capability to your extension. It then executes your extension, streaming a JSON CommandRef payload via stdin.echo '{\"primary\": \"test\"}' | devflow-ext-myext --build-action\n\nYour script reads this JSON struct, decides what underlying programs to call, and returns a JSON ExecutionAction to stdout.\n\nExample Python implementation:if \"--build-action\" in sys.argv:\n    # Read CommandRef from standard input\n    input_data = sys.stdin.read()\n    cmd_ref = json.loads(input_data)\n    \n    # Analyze the command\n    primary = cmd_ref.get(\"primary\")\n    selector = cmd_ref.get(\"selector\")\n    \n    # Tell Devflow what to execute\n    if primary == \"test\":\n        if selector == \"lint\":\n            action = {\"program\": \"flake8\", \"args\": [\".\"]}\n        else:\n            action = {\"program\": \"pytest\", \"args\": [\"tests/\"]}\n        \n        # Print the execution action for devflow to run\n        print(json.dumps(action))\n        sys.exit(0)","type":"content","url":"/writing-extensions#step-2-handling-build-action","position":7},{"hierarchy":{"lvl1":"Writing Custom Extensions","lvl2":"Developing and Debugging Locally"},"type":"lvl2","url":"/writing-extensions#developing-and-debugging-locally","position":8},{"hierarchy":{"lvl1":"Writing Custom Extensions","lvl2":"Developing and Debugging Locally"},"content":"Write your script: Write a script (e.g. devflow-ext-myext.sh or devflow-ext-python) handling --discover and --build-action. Make sure it’s executable (chmod +x).\n\nAdd to PATH: Add the directory containing your script to your system $PATH so Devflow can find it during discovery.export PATH=\"/path/to/your/script/dir:$PATH\"\n\nDebug independent of Devflow: Because the protocol is simply JSON over standard streams, you can test it directly in your terminal without Devflow:# Test discovery\n./devflow-ext-python --discover\n\n# Test building an action\necho '{\"primary\": \"test\", \"selector\": \"lint\"}' | ./devflow-ext-python --build-action\n\nExpected manual test output:\n{\"program\": \"flake8\", \"args\": [\".\"]}\n\nIntegration Test with Devflow: Once the CLI commands output correct JSON, you can run Devflow on any project and it will immediately delegate execution to your binary!","type":"content","url":"/writing-extensions#developing-and-debugging-locally","position":9},{"hierarchy":{"lvl1":"Writing Custom Extensions","lvl2":"Examples"},"type":"lvl2","url":"/writing-extensions#examples","position":10},{"hierarchy":{"lvl1":"Writing Custom Extensions","lvl2":"Examples"},"content":"We provide sample implementations of this protocol to guide your development:\n\nPython Example Extension","type":"content","url":"/writing-extensions#examples","position":11},{"hierarchy":{"lvl1":"CI Generation and Validation"},"type":"lvl1","url":"/ci","position":0},{"hierarchy":{"lvl1":"CI Generation and Validation"},"content":"ci:generate: generate workflow YAML.\n\nci:check: validate generated topology and command coverage.\n\nci:plan: list configured target profiles.","type":"content","url":"/ci","position":1},{"hierarchy":{"lvl1":"Infrastructure Overview"},"type":"lvl1","url":"/overview","position":0},{"hierarchy":{"lvl1":"Infrastructure Overview"},"content":"Devflow currently supports GitHub Actions workflow generation via devflow-gh.\n\nTarget CI topology contract:\n\nprep\n\nbuild\n\ncheck_* jobs mapped from targets.pr","type":"content","url":"/overview","position":1},{"hierarchy":{"lvl1":"Troubleshooting"},"type":"lvl1","url":"/troubleshooting-1","position":0},{"hierarchy":{"lvl1":"Troubleshooting"},"content":"","type":"content","url":"/troubleshooting-1","position":1},{"hierarchy":{"lvl1":"Troubleshooting","lvl2":"ci:check fails"},"type":"lvl2","url":"/troubleshooting-1#ci-check-fails","position":2},{"hierarchy":{"lvl1":"Troubleshooting","lvl2":"ci:check fails"},"content":"Run dwf --stdout ci:generate and inspect missing jobs/commands versus targets.pr.","type":"content","url":"/troubleshooting-1#ci-check-fails","position":3},{"hierarchy":{"lvl1":"Troubleshooting","lvl2":"Unsupported command in profile"},"type":"lvl2","url":"/troubleshooting-1#unsupported-command-in-profile","position":4},{"hierarchy":{"lvl1":"Troubleshooting","lvl2":"Unsupported command in profile"},"content":"Adjust profile commands or extension capabilities.","type":"content","url":"/troubleshooting-1#unsupported-command-in-profile","position":5},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint"},"type":"lvl1","url":"/brainstorm-implementation","position":0},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint"},"content":"","type":"content","url":"/brainstorm-implementation","position":1},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"1. Objective"},"type":"lvl2","url":"/brainstorm-implementation#id-1-objective","position":2},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"1. Objective"},"content":"This document translates the architecture into a production-ready implementation template covering:\n\nMulti-repo structure\n\nLayered crate constructs\n\nInterface & transport abstraction\n\nPlugin runtime traits (sandboxing, timeout, circuit breaker)\n\nCross-cutting traits (auth, tls, tracing, resilience)\n\nContract & DTO design\n\nDev + CI blueprint\n\nThe intent is to provide a repeatable template for building extensible Rust systems.","type":"content","url":"/brainstorm-implementation#id-1-objective","position":3},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"2. Repository Blueprint (Multi-Repo + Integration Workspace)"},"type":"lvl2","url":"/brainstorm-implementation#id-2-repository-blueprint-multi-repo-integration-workspace","position":4},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"2. Repository Blueprint (Multi-Repo + Integration Workspace)"},"content":"flowchart TD\n    coreRepo[core repo]\n    pluginRepo[plugin repos]\n    ifaceRepo[interface repo]\n    apiRepo[api-server repo]\n    cliRepo[cli repo]\n    webRepo[webapp repo]\n    wasmRepo[wasm adapter repo]\n    integration[integration workspace]\n\n    integration --> coreRepo\n    integration --> pluginRepo\n    integration --> ifaceRepo\n    integration --> apiRepo\n    integration --> cliRepo\n    integration --> wasmRepo","type":"content","url":"/brainstorm-implementation#id-2-repository-blueprint-multi-repo-integration-workspace","position":5},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"3. Core Crate Template"},"type":"lvl2","url":"/brainstorm-implementation#id-3-core-crate-template","position":6},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"3. Core Crate Template"},"content":"","type":"content","url":"/brainstorm-implementation#id-3-core-crate-template","position":7},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Directory structure","lvl2":"3. Core Crate Template"},"type":"lvl3","url":"/brainstorm-implementation#directory-structure","position":8},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Directory structure","lvl2":"3. Core Crate Template"},"content":"core/\n ├─ Cargo.toml\n ├─ src/\n │   ├─ domain/\n │   ├─ services/\n │   ├─ ports/\n │   ├─ plugin_api/\n │   ├─ errors.rs\n │   └─ lib.rs","type":"content","url":"/brainstorm-implementation#directory-structure","position":9},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Core design rules","lvl2":"3. Core Crate Template"},"type":"lvl3","url":"/brainstorm-implementation#core-design-rules","position":10},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Core design rules","lvl2":"3. Core Crate Template"},"content":"No transport dependencies\n\nNo serialization logic\n\nPure domain + workflows\n\nAsync traits for ports","type":"content","url":"/brainstorm-implementation#core-design-rules","position":11},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Example port trait","lvl2":"3. Core Crate Template"},"type":"lvl3","url":"/brainstorm-implementation#example-port-trait","position":12},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Example port trait","lvl2":"3. Core Crate Template"},"content":"#[async_trait::async_trait]\npub trait Storage: Send + Sync {\n    async fn save(&self, item: Project) -> Result<()>;\n}","type":"content","url":"/brainstorm-implementation#example-port-trait","position":13},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"4. Interface Crate Template"},"type":"lvl2","url":"/brainstorm-implementation#id-4-interface-crate-template","position":14},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"4. Interface Crate Template"},"content":"","type":"content","url":"/brainstorm-implementation#id-4-interface-crate-template","position":15},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Responsibilities","lvl2":"4. Interface Crate Template"},"type":"lvl3","url":"/brainstorm-implementation#responsibilities","position":16},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Responsibilities","lvl2":"4. Interface Crate Template"},"content":"DTOs\n\nMapping\n\nContract schemas\n\nVersioning","type":"content","url":"/brainstorm-implementation#responsibilities","position":17},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Structure","lvl2":"4. Interface Crate Template"},"type":"lvl3","url":"/brainstorm-implementation#structure","position":18},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Structure","lvl2":"4. Interface Crate Template"},"content":"interface/\n ├─ dto/\n ├─ mapping/\n ├─ schema/\n └─ lib.rs","type":"content","url":"/brainstorm-implementation#structure","position":19},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"DTO example","lvl2":"4. Interface Crate Template"},"type":"lvl3","url":"/brainstorm-implementation#dto-example","position":20},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"DTO example","lvl2":"4. Interface Crate Template"},"content":"#[derive(Serialize, Deserialize)]\npub struct ProjectDto {\n    pub id: String,\n    pub name: String,\n}","type":"content","url":"/brainstorm-implementation#dto-example","position":21},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Mapping example","lvl2":"4. Interface Crate Template"},"type":"lvl3","url":"/brainstorm-implementation#mapping-example","position":22},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Mapping example","lvl2":"4. Interface Crate Template"},"content":"impl From<Project> for ProjectDto {\n    fn from(p: Project) -> Self {\n        Self { id: p.id.to_string(), name: p.name }\n    }\n}","type":"content","url":"/brainstorm-implementation#mapping-example","position":23},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"5. Transport Abstraction Crate"},"type":"lvl2","url":"/brainstorm-implementation#id-5-transport-abstraction-crate","position":24},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"5. Transport Abstraction Crate"},"content":"","type":"content","url":"/brainstorm-implementation#id-5-transport-abstraction-crate","position":25},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Purpose","lvl2":"5. Transport Abstraction Crate"},"type":"lvl3","url":"/brainstorm-implementation#purpose","position":26},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Purpose","lvl2":"5. Transport Abstraction Crate"},"content":"Encapsulate HTTP, RPC, Events, IPC behind a unified trait model.","type":"content","url":"/brainstorm-implementation#purpose","position":27},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Transport traits","lvl2":"5. Transport Abstraction Crate"},"type":"lvl3","url":"/brainstorm-implementation#transport-traits","position":28},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Transport traits","lvl2":"5. Transport Abstraction Crate"},"content":"#[async_trait::async_trait]\npub trait RequestHandler {\n    async fn handle(&self, req: Payload) -> Result<Payload>;\n}\n\npub trait Transport {\n    fn start(self) -> Result<()>;\n}","type":"content","url":"/brainstorm-implementation#transport-traits","position":29},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"6. Serialization Strategy Crate"},"type":"lvl2","url":"/brainstorm-implementation#id-6-serialization-strategy-crate","position":30},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"6. Serialization Strategy Crate"},"content":"serde-strategy/\n ├─ json.rs\n ├─ msgpack.rs\n ├─ cbor.rs\n └─ lib.rs","type":"content","url":"/brainstorm-implementation#id-6-serialization-strategy-crate","position":31},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Serializer trait","lvl2":"6. Serialization Strategy Crate"},"type":"lvl3","url":"/brainstorm-implementation#serializer-trait","position":32},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Serializer trait","lvl2":"6. Serialization Strategy Crate"},"content":"pub trait Serializer {\n    fn encode<T: Serialize>(&self, value: &T) -> Result<Vec<u8>>;\n    fn decode<T: DeserializeOwned>(&self, data: &[u8]) -> Result<T>;\n}","type":"content","url":"/brainstorm-implementation#serializer-trait","position":33},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"7. Plugin Runtime Template"},"type":"lvl2","url":"/brainstorm-implementation#id-7-plugin-runtime-template","position":34},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"7. Plugin Runtime Template"},"content":"","type":"content","url":"/brainstorm-implementation#id-7-plugin-runtime-template","position":35},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Plugin crate structure","lvl2":"7. Plugin Runtime Template"},"type":"lvl3","url":"/brainstorm-implementation#plugin-crate-structure","position":36},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Plugin crate structure","lvl2":"7. Plugin Runtime Template"},"content":"plugin-example/\n ├─ src/lib.rs\n └─ manifest.toml","type":"content","url":"/brainstorm-implementation#plugin-crate-structure","position":37},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Plugin trait","lvl2":"7. Plugin Runtime Template"},"type":"lvl3","url":"/brainstorm-implementation#plugin-trait","position":38},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Plugin trait","lvl2":"7. Plugin Runtime Template"},"content":"#[async_trait::async_trait]\npub trait Plugin: Send + Sync {\n    fn metadata(&self) -> PluginMetadata;\n    async fn execute(&self, ctx: PluginContext) -> Result<PluginOutput>;\n}","type":"content","url":"/brainstorm-implementation#plugin-trait","position":39},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"8. Sandbox Trait (Security Boundary)"},"type":"lvl2","url":"/brainstorm-implementation#id-8-sandbox-trait-security-boundary","position":40},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"8. Sandbox Trait (Security Boundary)"},"content":"#[async_trait::async_trait]\npub trait Sandbox {\n    async fn run<F, T>(&self, f: F) -> Result<T>\n    where\n        F: Future<Output = Result<T>> + Send;\n}","type":"content","url":"/brainstorm-implementation#id-8-sandbox-trait-security-boundary","position":41},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"9. Timeout Wrapper Trait"},"type":"lvl2","url":"/brainstorm-implementation#id-9-timeout-wrapper-trait","position":42},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"9. Timeout Wrapper Trait"},"content":"#[async_trait::async_trait]\npub trait Timeout {\n    async fn with_timeout<F, T>(&self, dur: Duration, f: F) -> Result<T>\n    where\n        F: Future<Output = Result<T>> + Send;\n}","type":"content","url":"/brainstorm-implementation#id-9-timeout-wrapper-trait","position":43},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"10. Circuit Breaker Trait"},"type":"lvl2","url":"/brainstorm-implementation#id-10-circuit-breaker-trait","position":44},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"10. Circuit Breaker Trait"},"content":"#[async_trait::async_trait]\npub trait CircuitBreaker {\n    async fn call<F, T>(&self, key: &str, f: F) -> Result<T>\n    where\n        F: Future<Output = Result<T>> + Send;\n}","type":"content","url":"/brainstorm-implementation#id-10-circuit-breaker-trait","position":45},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"11. Secure Plugin Execution Stack"},"type":"lvl2","url":"/brainstorm-implementation#id-11-secure-plugin-execution-stack","position":46},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"11. Secure Plugin Execution Stack"},"content":"flowchart TD\n    plugin[Plugin]\n    sandbox[Sandbox]\n    timeout[Timeout]\n    breaker[Circuit Breaker]\n    core[Core]\n\n    plugin --> sandbox\n    sandbox --> timeout\n    timeout --> breaker\n    breaker --> core","type":"content","url":"/brainstorm-implementation#id-11-secure-plugin-execution-stack","position":47},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"12. Cross-Cutting Middleware Traits"},"type":"lvl2","url":"/brainstorm-implementation#id-12-cross-cutting-middleware-traits","position":48},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"12. Cross-Cutting Middleware Traits"},"content":"","type":"content","url":"/brainstorm-implementation#id-12-cross-cutting-middleware-traits","position":49},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Auth trait","lvl2":"12. Cross-Cutting Middleware Traits"},"type":"lvl3","url":"/brainstorm-implementation#auth-trait","position":50},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Auth trait","lvl2":"12. Cross-Cutting Middleware Traits"},"content":"#[async_trait::async_trait]\npub trait Authenticator {\n    async fn authenticate(&self, token: &str) -> Result<Identity>;\n}","type":"content","url":"/brainstorm-implementation#auth-trait","position":51},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"TLS abstraction","lvl2":"12. Cross-Cutting Middleware Traits"},"type":"lvl3","url":"/brainstorm-implementation#tls-abstraction","position":52},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"TLS abstraction","lvl2":"12. Cross-Cutting Middleware Traits"},"content":"pub trait TlsProvider {\n    fn client_config(&self) -> TlsConfig;\n    fn server_config(&self) -> TlsConfig;\n}","type":"content","url":"/brainstorm-implementation#tls-abstraction","position":53},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Observability trait","lvl2":"12. Cross-Cutting Middleware Traits"},"type":"lvl3","url":"/brainstorm-implementation#observability-trait","position":54},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Observability trait","lvl2":"12. Cross-Cutting Middleware Traits"},"content":"pub trait Telemetry {\n    fn record_span(&self, name: &str);\n    fn record_metric(&self, key: &str, value: f64);\n}","type":"content","url":"/brainstorm-implementation#observability-trait","position":55},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"13. API Server Template"},"type":"lvl2","url":"/brainstorm-implementation#id-13-api-server-template","position":56},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"13. API Server Template"},"content":"api-server/\n ├─ router/\n ├─ handlers/\n ├─ middleware/\n └─ main.rs","type":"content","url":"/brainstorm-implementation#id-13-api-server-template","position":57},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Handler example","lvl2":"13. API Server Template"},"type":"lvl3","url":"/brainstorm-implementation#handler-example","position":58},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Handler example","lvl2":"13. API Server Template"},"content":"async fn create_project(\n    Json(dto): Json<ProjectDto>,\n    State(app): State<AppState>,\n) -> Result<Json<ProjectDto>> {\n    let domain = dto.try_into()?;\n    let out = app.service.execute(domain).await?;\n    Ok(Json(out.into()))\n}","type":"content","url":"/brainstorm-implementation#handler-example","position":59},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"14. WASM Adapter Template"},"type":"lvl2","url":"/brainstorm-implementation#id-14-wasm-adapter-template","position":60},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"14. WASM Adapter Template"},"content":"wasm/\n ├─ bindings.rs\n └─ lib.rs","type":"content","url":"/brainstorm-implementation#id-14-wasm-adapter-template","position":61},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"WASM boundary example","lvl2":"14. WASM Adapter Template"},"type":"lvl3","url":"/brainstorm-implementation#wasm-boundary-example","position":62},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"WASM boundary example","lvl2":"14. WASM Adapter Template"},"content":"#[wasm_bindgen]\npub async fn run(input: JsValue) -> Result<JsValue, JsValue> {\n    let dto: ProjectDto = serde_wasm_bindgen::from_value(input)?;\n    let out = service.execute(dto.try_into()?).await?;\n    Ok(serde_wasm_bindgen::to_value(&ProjectDto::from(out))?)\n}","type":"content","url":"/brainstorm-implementation#wasm-boundary-example","position":63},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"15. Event Interface Template"},"type":"lvl2","url":"/brainstorm-implementation#id-15-event-interface-template","position":64},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"15. Event Interface Template"},"content":"pub trait EventBus {\n    async fn publish(&self, evt: Event) -> Result<()>;\n    async fn subscribe(&self, topic: &str) -> Result<Stream<Event>>;\n}","type":"content","url":"/brainstorm-implementation#id-15-event-interface-template","position":65},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"16. Error Model"},"type":"lvl2","url":"/brainstorm-implementation#id-16-error-model","position":66},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"16. Error Model"},"content":"#[derive(thiserror::Error)]\npub enum AppError {\n    #[error(\"validation error\")]\n    Validation,\n    #[error(\"internal error\")]\n    Internal,\n}","type":"content","url":"/brainstorm-implementation#id-16-error-model","position":67},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"17. Dev Workflow Blueprint"},"type":"lvl2","url":"/brainstorm-implementation#id-17-dev-workflow-blueprint","position":68},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"17. Dev Workflow Blueprint"},"content":"","type":"content","url":"/brainstorm-implementation#id-17-dev-workflow-blueprint","position":69},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Dev mode","lvl2":"17. Dev Workflow Blueprint"},"type":"lvl3","url":"/brainstorm-implementation#dev-mode","position":70},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Dev mode","lvl2":"17. Dev Workflow Blueprint"},"content":"JSON serialization\n\nIn-memory plugins\n\nLocal transport\n\nDebug tracing","type":"content","url":"/brainstorm-implementation#dev-mode","position":71},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Prod mode","lvl2":"17. Dev Workflow Blueprint"},"type":"lvl3","url":"/brainstorm-implementation#prod-mode","position":72},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl3":"Prod mode","lvl2":"17. Dev Workflow Blueprint"},"content":"Binary serialization internal\n\nWASM plugins\n\nCDN assets\n\nTLS enforced\n\nCircuit breaker enabled","type":"content","url":"/brainstorm-implementation#prod-mode","position":73},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"18. CI/CD Blueprint"},"type":"lvl2","url":"/brainstorm-implementation#id-18-ci-cd-blueprint","position":74},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"18. CI/CD Blueprint"},"content":"Contract compatibility tests\n\nPlugin conformance tests\n\nIntegration workspace build\n\nSchema diff validation\n\nWASM plugin test harness","type":"content","url":"/brainstorm-implementation#id-18-ci-cd-blueprint","position":75},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"19. Risk Mitigation Mapping"},"type":"lvl2","url":"/brainstorm-implementation#id-19-risk-mitigation-mapping","position":76},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"19. Risk Mitigation Mapping"},"content":"Risk\n\nMitigation\n\nVersion drift\n\ncontract pinning\n\nPlugin ABI\n\nWASM boundary\n\nDebuggability\n\nJSON debug mirror\n\nIntegration\n\nmeta workspace\n\nSerialization overhead\n\nbinary internal\n\nSecurity\n\nsandbox + capability model","type":"content","url":"/brainstorm-implementation#id-19-risk-mitigation-mapping","position":77},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"20. Next Steps"},"type":"lvl2","url":"/brainstorm-implementation#id-20-next-steps","position":78},{"hierarchy":{"lvl1":"Rust Multi-Surface Architecture — Implementation Blueprint","lvl2":"20. Next Steps"},"content":"Potential follow-ups:\n\nReference implementation repo\n\nPlugin manifest spec\n\nWASM plugin runtime design\n\nContract compatibility checker\n\nDevcontainer blueprint\n\nAdapter test harness\n\nMulti-repo release orchestration","type":"content","url":"/brainstorm-implementation#id-20-next-steps","position":79},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)"},"type":"lvl1","url":"/brainstorm-re-architecture","position":0},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)"},"content":"","type":"content","url":"/brainstorm-re-architecture","position":1},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"1. Context"},"type":"lvl2","url":"/brainstorm-re-architecture#id-1-context","position":2},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"1. Context"},"content":"This revision introduces a first-class Interface & Communication Layer that sits above the typed core and enables:\n\nTransport abstraction (HTTP, RPC, Events, IPC)\n\nPluggable serialization formats\n\nZero-config sensible defaults\n\nEvolution without breaking adapters\n\nUniform debugging & observability\n\nThe goal is to preserve strong typing internally while allowing flexible external interfaces.","type":"content","url":"/brainstorm-re-architecture#id-1-context","position":3},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"2. Updated High-Level Architecture"},"type":"lvl2","url":"/brainstorm-re-architecture#id-2-updated-high-level-architecture","position":4},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"2. Updated High-Level Architecture"},"content":"flowchart LR\n    core[Typed Core<br/>Domain + Services]\n    plugins[Plugins]\n    iface[Interface Layer<br/>Contracts + Payload + SerDe]\n    transport[Transport Layer]\n    adapters[Adapters]\n\n    core --> plugins\n    core --> iface\n    plugins --> iface\n    iface --> transport\n    transport --> adapters","type":"content","url":"/brainstorm-re-architecture#id-2-updated-high-level-architecture","position":5},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl4":"Key insight","lvl2":"2. Updated High-Level Architecture"},"type":"lvl4","url":"/brainstorm-re-architecture#key-insight","position":6},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl4":"Key insight","lvl2":"2. Updated High-Level Architecture"},"content":"Core does not depend on transport or serialization.Interfaces mediate between typed domain and external world.","type":"content","url":"/brainstorm-re-architecture#key-insight","position":7},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"3. Interface Layer Responsibilities"},"type":"lvl2","url":"/brainstorm-re-architecture#id-3-interface-layer-responsibilities","position":8},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"3. Interface Layer Responsibilities"},"content":"","type":"content","url":"/brainstorm-re-architecture#id-3-interface-layer-responsibilities","position":9},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Responsibilities","lvl2":"3. Interface Layer Responsibilities"},"type":"lvl3","url":"/brainstorm-re-architecture#responsibilities","position":10},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Responsibilities","lvl2":"3. Interface Layer Responsibilities"},"content":"Define contracts\n\nMap domain ↔ payload\n\nHandle serialization formats\n\nVersioning\n\nValidation\n\nError normalization","type":"content","url":"/brainstorm-re-architecture#responsibilities","position":11},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Interface layer decomposition","lvl2":"3. Interface Layer Responsibilities"},"type":"lvl3","url":"/brainstorm-re-architecture#interface-layer-decomposition","position":12},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Interface layer decomposition","lvl2":"3. Interface Layer Responsibilities"},"content":"flowchart TD\n    contracts[Contracts<br/>Schema / WIT / OpenAPI]\n    mapping[Domain ↔ DTO Mapping]\n    payload[Payload Layer]\n    serde[SerDe Strategy]\n    versioning[Versioning]\n\n    contracts --> mapping\n    mapping --> payload\n    payload --> serde\n    contracts --> versioning","type":"content","url":"/brainstorm-re-architecture#interface-layer-decomposition","position":13},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"4. Transport Layer"},"type":"lvl2","url":"/brainstorm-re-architecture#id-4-transport-layer","position":14},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"4. Transport Layer"},"content":"Transport becomes a thin envelope around payload.flowchart TD\n    http[HTTP]\n    rpc[RPC]\n    events[Events]\n    ipc[IPC]\n    cli[CLI IO]\n\n    http --> payload[Payload]\n    rpc --> payload\n    events --> payload\n    ipc --> payload\n    cli --> payload\n\nThis separation enables:\n\nSame payload across transports\n\nAdapter portability\n\nBetter testability","type":"content","url":"/brainstorm-re-architecture#id-4-transport-layer","position":15},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"5. Payload Strategy"},"type":"lvl2","url":"/brainstorm-re-architecture#id-5-payload-strategy","position":16},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"5. Payload Strategy"},"content":"","type":"content","url":"/brainstorm-re-architecture#id-5-payload-strategy","position":17},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"DTO layer (external representation)","lvl2":"5. Payload Strategy"},"type":"lvl3","url":"/brainstorm-re-architecture#dto-layer-external-representation","position":18},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"DTO layer (external representation)","lvl2":"5. Payload Strategy"},"content":"Immutable\n\nBackward compatible\n\nExplicit versioning\n\nNo domain invariants","type":"content","url":"/brainstorm-re-architecture#dto-layer-external-representation","position":19},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Mapping layer","lvl2":"5. Payload Strategy"},"type":"lvl3","url":"/brainstorm-re-architecture#mapping-layer","position":20},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Mapping layer","lvl2":"5. Payload Strategy"},"content":"Domain → DTO\n\nDTO → Domain (validation)","type":"content","url":"/brainstorm-re-architecture#mapping-layer","position":21},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"6. Serialization Strategy"},"type":"lvl2","url":"/brainstorm-re-architecture#id-6-serialization-strategy","position":22},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"6. Serialization Strategy"},"content":"","type":"content","url":"/brainstorm-re-architecture#id-6-serialization-strategy","position":23},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Requirements","lvl2":"6. Serialization Strategy"},"type":"lvl3","url":"/brainstorm-re-architecture#requirements","position":24},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Requirements","lvl2":"6. Serialization Strategy"},"content":"Human friendly (debugging)\n\nEfficient\n\nEvolvable\n\nLanguage neutral","type":"content","url":"/brainstorm-re-architecture#requirements","position":25},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Multi-format SerDe model","lvl2":"6. Serialization Strategy"},"type":"lvl3","url":"/brainstorm-re-architecture#multi-format-serde-model","position":26},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Multi-format SerDe model","lvl2":"6. Serialization Strategy"},"content":"flowchart LR\n    dto[DTO Payload]\n    json[JSON]\n    cbor[CBOR]\n    msgpack[MsgPack]\n    proto[Protobuf]\n\n    dto --> json\n    dto --> cbor\n    dto --> msgpack\n    dto --> proto","type":"content","url":"/brainstorm-re-architecture#multi-format-serde-model","position":27},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Recommended defaults","lvl2":"6. Serialization Strategy"},"type":"lvl3","url":"/brainstorm-re-architecture#recommended-defaults","position":28},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Recommended defaults","lvl2":"6. Serialization Strategy"},"content":"Context\n\nFormat\n\nPublic API\n\nJSON\n\nInternal RPC\n\nMessagePack\n\nEvents\n\nJSON / CloudEvents\n\nWASM\n\nWIT\n\nHigh throughput\n\nCBOR","type":"content","url":"/brainstorm-re-architecture#recommended-defaults","position":29},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"7. Zero-Config Strategy"},"type":"lvl2","url":"/brainstorm-re-architecture#id-7-zero-config-strategy","position":30},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"7. Zero-Config Strategy"},"content":"","type":"content","url":"/brainstorm-re-architecture#id-7-zero-config-strategy","position":31},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Default path","lvl2":"7. Zero-Config Strategy"},"type":"lvl3","url":"/brainstorm-re-architecture#default-path","position":32},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Default path","lvl2":"7. Zero-Config Strategy"},"content":"flowchart LR\n    core --> dto\n    dto --> json\n    json --> http\n\nNo configuration required for most users.\n\nAdvanced users can override:\n\nserialization format\n\ntransport\n\nversion negotiation","type":"content","url":"/brainstorm-re-architecture#default-path","position":33},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"8. Multi-Surface Interaction Flow"},"type":"lvl2","url":"/brainstorm-re-architecture#id-8-multi-surface-interaction-flow","position":34},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"8. Multi-Surface Interaction Flow"},"content":"sequenceDiagram\n    participant UI\n    participant Transport\n    participant Interface\n    participant Core\n    participant Plugins\n\n    UI->>Transport: Request\n    Transport->>Interface: Envelope\n    Interface->>Core: Typed input\n    Core->>Plugins: Execute\n    Plugins-->>Core: Result\n    Core-->>Interface: Typed output\n    Interface-->>Transport: Serialized payload\n    Transport-->>UI: Response","type":"content","url":"/brainstorm-re-architecture#id-8-multi-surface-interaction-flow","position":35},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"9. Risk Mitigation Strategies"},"type":"lvl2","url":"/brainstorm-re-architecture#id-9-risk-mitigation-strategies","position":36},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"9. Risk Mitigation Strategies"},"content":"","type":"content","url":"/brainstorm-re-architecture#id-9-risk-mitigation-strategies","position":37},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Risk 1 — Version drift across repos","lvl2":"9. Risk Mitigation Strategies"},"type":"lvl3","url":"/brainstorm-re-architecture#risk-1-version-drift-across-repos","position":38},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Risk 1 — Version drift across repos","lvl2":"9. Risk Mitigation Strategies"},"content":"","type":"content","url":"/brainstorm-re-architecture#risk-1-version-drift-across-repos","position":39},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl4":"Mitigation","lvl3":"Risk 1 — Version drift across repos","lvl2":"9. Risk Mitigation Strategies"},"type":"lvl4","url":"/brainstorm-re-architecture#mitigation","position":40},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl4":"Mitigation","lvl3":"Risk 1 — Version drift across repos","lvl2":"9. Risk Mitigation Strategies"},"content":"Contract-first design\n\nSchema version pinning\n\nCompatibility test suite\n\nInterface conformance tests","type":"content","url":"/brainstorm-re-architecture#mitigation","position":41},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Risk 2 — Serialization overhead","lvl2":"9. Risk Mitigation Strategies"},"type":"lvl3","url":"/brainstorm-re-architecture#risk-2-serialization-overhead","position":42},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Risk 2 — Serialization overhead","lvl2":"9. Risk Mitigation Strategies"},"content":"","type":"content","url":"/brainstorm-re-architecture#risk-2-serialization-overhead","position":43},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl4":"Mitigation","lvl3":"Risk 2 — Serialization overhead","lvl2":"9. Risk Mitigation Strategies"},"type":"lvl4","url":"/brainstorm-re-architecture#mitigation-1","position":44},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl4":"Mitigation","lvl3":"Risk 2 — Serialization overhead","lvl2":"9. Risk Mitigation Strategies"},"content":"Binary formats for internal paths\n\nZero-copy deserialization where possible\n\nDTO flattening\n\nAvoid domain → DTO churn","type":"content","url":"/brainstorm-re-architecture#mitigation-1","position":45},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Risk 3 — Plugin ABI instability","lvl2":"9. Risk Mitigation Strategies"},"type":"lvl3","url":"/brainstorm-re-architecture#risk-3-plugin-abi-instability","position":46},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Risk 3 — Plugin ABI instability","lvl2":"9. Risk Mitigation Strategies"},"content":"","type":"content","url":"/brainstorm-re-architecture#risk-3-plugin-abi-instability","position":47},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl4":"Mitigation","lvl3":"Risk 3 — Plugin ABI instability","lvl2":"9. Risk Mitigation Strategies"},"type":"lvl4","url":"/brainstorm-re-architecture#mitigation-2","position":48},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl4":"Mitigation","lvl3":"Risk 3 — Plugin ABI instability","lvl2":"9. Risk Mitigation Strategies"},"content":"WASM plugin boundary\n\nStable plugin API crate\n\nCapability-based interfaces\n\nVersion handshake","type":"content","url":"/brainstorm-re-architecture#mitigation-2","position":49},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Risk 4 — Integration complexity","lvl2":"9. Risk Mitigation Strategies"},"type":"lvl3","url":"/brainstorm-re-architecture#risk-4-integration-complexity","position":50},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Risk 4 — Integration complexity","lvl2":"9. Risk Mitigation Strategies"},"content":"","type":"content","url":"/brainstorm-re-architecture#risk-4-integration-complexity","position":51},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl4":"Mitigation","lvl3":"Risk 4 — Integration complexity","lvl2":"9. Risk Mitigation Strategies"},"type":"lvl4","url":"/brainstorm-re-architecture#mitigation-3","position":52},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl4":"Mitigation","lvl3":"Risk 4 — Integration complexity","lvl2":"9. Risk Mitigation Strategies"},"content":"Meta integration repo\n\nContract mocks\n\nAdapter test harness\n\nDevcontainer for reproducibility","type":"content","url":"/brainstorm-re-architecture#mitigation-3","position":53},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Risk 5 — Debuggability loss with binary formats","lvl2":"9. Risk Mitigation Strategies"},"type":"lvl3","url":"/brainstorm-re-architecture#risk-5-debuggability-loss-with-binary-formats","position":54},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Risk 5 — Debuggability loss with binary formats","lvl2":"9. Risk Mitigation Strategies"},"content":"","type":"content","url":"/brainstorm-re-architecture#risk-5-debuggability-loss-with-binary-formats","position":55},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl4":"Mitigation","lvl3":"Risk 5 — Debuggability loss with binary formats","lvl2":"9. Risk Mitigation Strategies"},"type":"lvl4","url":"/brainstorm-re-architecture#mitigation-4","position":56},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl4":"Mitigation","lvl3":"Risk 5 — Debuggability loss with binary formats","lvl2":"9. Risk Mitigation Strategies"},"content":"Debug mode JSON mirror\n\nStructured tracing payload logs\n\nSchema-aware inspector tools","type":"content","url":"/brainstorm-re-architecture#mitigation-4","position":57},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"10. Evolution Strategy"},"type":"lvl2","url":"/brainstorm-re-architecture#id-10-evolution-strategy","position":58},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"10. Evolution Strategy"},"content":"","type":"content","url":"/brainstorm-re-architecture#id-10-evolution-strategy","position":59},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Layered evolution model","lvl2":"10. Evolution Strategy"},"type":"lvl3","url":"/brainstorm-re-architecture#layered-evolution-model","position":60},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Layered evolution model","lvl2":"10. Evolution Strategy"},"content":"flowchart TD\n    domain[Domain]\n    contracts[Contracts]\n    payload[Payload]\n    serde[SerDe]\n    transport[Transport]\n\n    domain --> contracts\n    contracts --> payload\n    payload --> serde\n    serde --> transport","type":"content","url":"/brainstorm-re-architecture#layered-evolution-model","position":61},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl4":"Principle","lvl3":"Layered evolution model","lvl2":"10. Evolution Strategy"},"type":"lvl4","url":"/brainstorm-re-architecture#principle","position":62},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl4":"Principle","lvl3":"Layered evolution model","lvl2":"10. Evolution Strategy"},"content":"Each layer evolves independently with compatibility guarantees.","type":"content","url":"/brainstorm-re-architecture#principle","position":63},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"11. Contract Strategy"},"type":"lvl2","url":"/brainstorm-re-architecture#id-11-contract-strategy","position":64},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"11. Contract Strategy"},"content":"","type":"content","url":"/brainstorm-re-architecture#id-11-contract-strategy","position":65},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Contract sources","lvl2":"11. Contract Strategy"},"type":"lvl3","url":"/brainstorm-re-architecture#contract-sources","position":66},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Contract sources","lvl2":"11. Contract Strategy"},"content":"OpenAPI (HTTP)\n\nJSON Schema (DTO)\n\nWIT (WASM)\n\nProtobuf (optional internal)","type":"content","url":"/brainstorm-re-architecture#contract-sources","position":67},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Contract sharing","lvl2":"11. Contract Strategy"},"type":"lvl3","url":"/brainstorm-re-architecture#contract-sharing","position":68},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Contract sharing","lvl2":"11. Contract Strategy"},"content":"flowchart LR\n    schema[Schema Source]\n    rust[Rust Types]\n    ts[TS Types]\n    docs[Docs]\n\n    schema --> rust\n    schema --> ts\n    schema --> docs","type":"content","url":"/brainstorm-re-architecture#contract-sharing","position":69},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"12. Error Handling Model"},"type":"lvl2","url":"/brainstorm-re-architecture#id-12-error-handling-model","position":70},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"12. Error Handling Model"},"content":"","type":"content","url":"/brainstorm-re-architecture#id-12-error-handling-model","position":71},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Unified error envelope","lvl2":"12. Error Handling Model"},"type":"lvl3","url":"/brainstorm-re-architecture#unified-error-envelope","position":72},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl3":"Unified error envelope","lvl2":"12. Error Handling Model"},"content":"{\n  \"type\": \"https://example/errors/invalid-input\",\n  \"title\": \"Invalid input\",\n  \"detail\": \"...\",\n  \"trace_id\": \"...\",\n  \"instance\": \"...\",\n  \"metadata\": {}\n}\n\nBased on RFC7807.","type":"content","url":"/brainstorm-re-architecture#unified-error-envelope","position":73},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"13. Security Strategy"},"type":"lvl2","url":"/brainstorm-re-architecture#id-13-security-strategy","position":74},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"13. Security Strategy"},"content":"Capability-based plugin permissions\n\nSigned plugin manifests\n\nSchema validation\n\nInput sanitization\n\nEvent provenance\n\nContent Security Policy (webviews)\n\nTransport encryption","type":"content","url":"/brainstorm-re-architecture#id-13-security-strategy","position":75},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"14. Trade-off Summary"},"type":"lvl2","url":"/brainstorm-re-architecture#id-14-trade-off-summary","position":76},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"14. Trade-off Summary"},"content":"Decision\n\nBenefit\n\nCost\n\nSeparate transport & payload\n\nFlexibility\n\nComplexity\n\nInterface layer\n\nEvolution safety\n\nExtra mapping\n\nMulti-format SerDe\n\nPerformance\n\nTooling overhead\n\nContract-first design\n\nStability\n\nSlower iteration\n\nWASM plugins\n\nSafety\n\nRuntime overhead","type":"content","url":"/brainstorm-re-architecture#id-14-trade-off-summary","position":77},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"15. Final Opinionated Model"},"type":"lvl2","url":"/brainstorm-re-architecture#id-15-final-opinionated-model","position":78},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"15. Final Opinionated Model"},"content":"Layer\n\nResponsibility\n\nCore\n\nDomain + workflows\n\nPlugins\n\nCapability extension\n\nInterface\n\nContracts + mapping\n\nPayload\n\nDTO\n\nSerDe\n\nEncoding\n\nTransport\n\nDelivery\n\nAdapters\n\nSurface integration","type":"content","url":"/brainstorm-re-architecture#id-15-final-opinionated-model","position":79},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"16. Future Evolution Opportunities"},"type":"lvl2","url":"/brainstorm-re-architecture#id-16-future-evolution-opportunities","position":80},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"16. Future Evolution Opportunities"},"content":"Agent-native interfaces\n\nGraph-based contracts\n\nSchema registry\n\nEvent mesh\n\nEdge adapter layer\n\nSemantic version negotiation\n\nSelf-describing plugins","type":"content","url":"/brainstorm-re-architecture#id-16-future-evolution-opportunities","position":81},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"17. Next Possible Deep Dives"},"type":"lvl2","url":"/brainstorm-re-architecture#id-17-next-possible-deep-dives","position":82},{"hierarchy":{"lvl1":"Rust Multi-Surface App Architecture Blueprint (v2)","lvl2":"17. Next Possible Deep Dives"},"content":"DTO mapping patterns (Rust)\n\nWIT contract examples\n\nPlugin runtime protocol\n\nSchema evolution patterns\n\nAdapter test harness design\n\nMulti-repo CI orchestration\n\nContract compatibility checker","type":"content","url":"/brainstorm-re-architecture#id-17-next-possible-deep-dives","position":83},{"hierarchy":{"lvl1":"Roadmap and Planning"},"type":"lvl1","url":"/index-2","position":0},{"hierarchy":{"lvl1":"Roadmap and Planning"},"content":"This section tracks strategic planning, design reviews, and implementation execution artifacts.","type":"content","url":"/index-2","position":1},{"hierarchy":{"lvl1":"SWOT Analysis: Devflow Positioning"},"type":"lvl1","url":"/swot-analysis","position":0},{"hierarchy":{"lvl1":"SWOT Analysis: Devflow Positioning"},"content":"This analysis evaluates DevFlow’s position within the “CI Parity” and “DevOps Automation” landscape, based on current industry trends and competitive tool analysis.","type":"content","url":"/swot-analysis","position":1},{"hierarchy":{"lvl1":"SWOT Analysis: Devflow Positioning","lvl2":"Strengths"},"type":"lvl2","url":"/swot-analysis#strengths","position":2},{"hierarchy":{"lvl1":"SWOT Analysis: Devflow Positioning","lvl2":"Strengths"},"content":"Canonical Command Surface: Provides a stable CLI (dwf) that abstracts where tasks run (local host, containerized local, CI).\n\nWorkflow Consistency: Ensures that the same commands developers use locally are exactly what the CI platform executes, reducing “works on my machine” syndrome.\n\nLanguage/Stack Agnostic: Designed to orchestrate across different stacks without forcing a specific language SDK (unlike Dagger).\n\nDeveloper Experience (DX): Focuses on simplifying the developer loop through deterministic orchestration.","type":"content","url":"/swot-analysis#strengths","position":3},{"hierarchy":{"lvl1":"SWOT Analysis: Devflow Positioning","lvl2":"Weaknesses"},"type":"lvl2","url":"/swot-analysis#weaknesses","position":4},{"hierarchy":{"lvl1":"SWOT Analysis: Devflow Positioning","lvl2":"Weaknesses"},"content":"Manual Wiring: Currently requires manual configuration of local vs. CI flags for certain tasks.\n\nComplexity Overhead: For very small projects, a custom orchestrator might feel like overkill compared to a simple Makefile or justfile.\n\nResource Management: Unlike container-native tools (Earthly, Dagger), DevFlow relies on the host or predefined containers rather than orchestrating its own isolated build graph.\n\nEarly Product Maturity: Command coverage and extension execution behavior are still expanding; users may hit gaps in non-Rust/Node stacks.","type":"content","url":"/swot-analysis#weaknesses","position":5},{"hierarchy":{"lvl1":"SWOT Analysis: Devflow Positioning","lvl2":"Opportunities"},"type":"lvl2","url":"/swot-analysis#opportunities","position":6},{"hierarchy":{"lvl1":"SWOT Analysis: Devflow Positioning","lvl2":"Opportunities"},"content":"Engineering Platform Extension: Potential to evolve from a “task runner” into a full-scale engineering platform that manages environment state and cloud-native integrations.\n\nIntegration with SDK-based CI: Opportunity to wrap tools like Dagger to provide a more “human-friendly” CLI interface while leveraging their advanced caching/isolation.\n\nStandardized CI Parity: Position as the go-to standard for teams wanting to escape CI vendor lock-in without moving to complex Kubernetes-native orchestration.\n\nDogfooding Feedback Loop: Using Devflow on itself can rapidly improve UX, docs quality, and policy design when done with fallback paths.","type":"content","url":"/swot-analysis#opportunities","position":7},{"hierarchy":{"lvl1":"SWOT Analysis: Devflow Positioning","lvl2":"Threats"},"type":"lvl2","url":"/swot-analysis#threats","position":8},{"hierarchy":{"lvl1":"SWOT Analysis: Devflow Positioning","lvl2":"Threats"},"content":"Rising SDK Dominance: Tools like Dagger are gaining traction by moving CI logic into standard programming languages, which might reduce the need for CLI-based orchestrators.\n\nImproved Native CI Tooling: If GitHub Actions or GitLab CI provide first-class, high-performance local runners, the need for third-party parity tools may diminish.\n\nMaintenance/Status of Competitors: While some competitors (like Earthly) are pivoting, the rapid evolution of this space means new, more automated tools appear frequently.","type":"content","url":"/swot-analysis#threats","position":9},{"hierarchy":{"lvl1":"SWOT Analysis: Devflow Positioning","lvl2":"Review Notes and Recommended Positioning"},"type":"lvl2","url":"/swot-analysis#review-notes-and-recommended-positioning","position":10},{"hierarchy":{"lvl1":"SWOT Analysis: Devflow Positioning","lvl2":"Review Notes and Recommended Positioning"},"content":"Most defensible wedge: deterministic policy-driven command contract (check:*, ci:*) rather than full build-system replacement.\n\nPrimary differentiation: ease of adoption + explicit workflow contract, not raw execution graph sophistication.\n\nDogfooding should be phased:\n\nkeep direct fallback (cargo check/test) until stable release gates are proven\n\nprogressively move project CI and local contributor flow to dwf\n\nGo-to-market sequencing:\n\nstart with teams already feeling local/CI drift pain\n\nprovide migration templates from Makefile/NPM scripts to devflow.toml\n\nprioritize observability of what each command/profile does (clear logs and docs)","type":"content","url":"/swot-analysis#review-notes-and-recommended-positioning","position":11},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal"},"type":"lvl1","url":"/v0-1-0-ci-container-redesign","position":0},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal"},"content":"","type":"content","url":"/v0-1-0-ci-container-redesign","position":1},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl2":"Purpose"},"type":"lvl2","url":"/v0-1-0-ci-container-redesign#purpose","position":2},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl2":"Purpose"},"content":"Define a reproducible, modular, and cache-efficient developer/CI model for the v0.1.0 refactor so local macOS development and GitHub Actions execute the same verification logic with the same container identity.","type":"content","url":"/v0-1-0-ci-container-redesign#purpose","position":3},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl2":"Executive Summary"},"type":"lvl2","url":"/v0-1-0-ci-container-redesign#executive-summary","position":4},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl2":"Executive Summary"},"content":"Keep the current fingerprinted CI image strategy and expand it into a single canonical cache architecture.\n\nUse a configurable cache root for local container runs (default: .cargo-cache/) with explicit volume mounts for registry, git, sccache, and target outputs.\n\nKeep one source of truth for commands in Make targets and scripts; GitHub Actions should only orchestrate those targets.\n\nUse cargo nextest as the default PR test runner, with test tiers split by change risk (minimal PR gate vs full verification on push/main).\n\nPreserve granular PR visibility (fmt, clippy, compile, test, smoke) as separate required checks.\n\nKeep build and verify execution inside the containerized CI image to preserve environment parity with local repro.","type":"content","url":"/v0-1-0-ci-container-redesign#executive-summary","position":5},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl2":"Current-State Evaluation"},"type":"lvl2","url":"/v0-1-0-ci-container-redesign#current-state-evaluation","position":6},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl2":"Current-State Evaluation"},"content":"This repository already has strong foundations:\n\nContent-addressed image fingerprinting (Dockerfile hash) and GHCR-backed CI image identity.\n\nContainerized local reproducibility via ./dflow ci-verify.\n\nShared cache directories for containerized runs: .cargo-cache/{registry,git,sccache} and target/ci.\n\nnextest already used in test-ci.\n\nGranular status reporting via gh-check-wrapper.sh.\n\nPrimary gaps to address for v0.1.0:\n\nFingerprint scope drift: docs/scripts currently state broader fingerprint inputs, while vars.mk hashes only Dockerfile.\n\nCache root is not fully standardized/configurable as one top-level contract for local + CI.\n\nCI check topology is efficient but still tightly coupled to shell backgrounding in one step; explicit check job contracts can improve maintainability.\n\nPR gating tiers are not explicitly documented as “minimal gate” vs “full verification”.\n\nThe design is highly optimized for this Rust repository but is not yet framed as a reusable cross-stack platform.","type":"content","url":"/v0-1-0-ci-container-redesign#current-state-evaluation","position":7},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl2":"Target Design"},"type":"lvl2","url":"/v0-1-0-ci-container-redesign#target-design","position":8},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl2":"Target Design"},"content":"","type":"content","url":"/v0-1-0-ci-container-redesign#target-design","position":9},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"1) Canonical Build Identity","lvl2":"Target Design"},"type":"lvl3","url":"/v0-1-0-ci-container-redesign#id-1-canonical-build-identity","position":10},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"1) Canonical Build Identity","lvl2":"Target Design"},"content":"Keep image fingerprinting as the environment identity key.\n\nExpand fingerprint inputs to match policy: Dockerfile, Makefile, install.sh, src-scripts/**, and rust-toolchain.toml.\n\nPublish CI image as ghcr.io/<repo>-ci:<fingerprint> and keep :latest as convenience only.\n\nUse immutable digest pinning in CI job container declarations when practical.","type":"content","url":"/v0-1-0-ci-container-redesign#id-1-canonical-build-identity","position":11},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"2) Unified Cache Contract","lvl2":"Target Design"},"type":"lvl3","url":"/v0-1-0-ci-container-redesign#id-2-unified-cache-contract","position":12},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"2) Unified Cache Contract","lvl2":"Target Design"},"content":"Define one configurable cache root:\n\nKROKI_CACHE_ROOT (default .cargo-cache)\n\nSubdirs:\n\n${KROKI_CACHE_ROOT}/registry\n\n${KROKI_CACHE_ROOT}/git\n\n${KROKI_CACHE_ROOT}/sccache\n\n${KROKI_CACHE_ROOT}/target-ci\n\n${KROKI_CACHE_ROOT}/image-tar\n\n${KROKI_CACHE_ROOT}/buildx\n\nLocal container mounts:\n\nCargo registry/git -> mounted from KROKI_CACHE_ROOT.\n\nSCCACHE_DIR -> mounted from KROKI_CACHE_ROOT/sccache.\n\nCARGO_TARGET_DIR -> mounted from KROKI_CACHE_ROOT/target-ci.\n\nGuidance:\n\nDo not mount host ~/.cargo directly by default; use project-scoped cache roots for reproducibility and isolation.\n\nKeep target caches scoped by Rust version + fingerprint + feature set to avoid artifact poisoning.\n\nEnvironment nuance impact:\n\nA standardized cache root does not remove environment-specific capability differences (kernel, filesystem semantics, CPU arch, cgroup limits, sandboxing).\n\nThe container image and run flags define behavior parity; the cache root only standardizes persisted artifacts and speeds reruns.\n\nCache key dimensions should include os/arch and runtime profile (for example Linux amd64 container vs local native macOS) to avoid cross-environment contamination.\n\nFor deterministic CI, treat cache as an optimization only; correctness must not depend on cache hits.","type":"content","url":"/v0-1-0-ci-container-redesign#id-2-unified-cache-contract","position":13},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"3) GitHub Actions Cache Layers","lvl2":"Target Design"},"type":"lvl3","url":"/v0-1-0-ci-container-redesign#id-3-github-actions-cache-layers","position":14},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"3) GitHub Actions Cache Layers","lvl2":"Target Design"},"content":"Use layered caching, ordered by ROI:\n\nCI image reuse from GHCR by fingerprint.\n\nOptional image tar cache (actions/cache) for fast same-runner restore.\n\nCargo + sccache cache (registry, git, sccache, target-ci) keyed by:\n\nrunner.os\n\nimage fingerprint\n\nhash(Cargo.lock, rust-toolchain.toml)\n\ncargo feature mode (for example native-browser vs lean)\n\nBuildKit cache for image builds (cache-from/cache-to gha, optionally registry cache manifest).","type":"content","url":"/v0-1-0-ci-container-redesign#id-3-github-actions-cache-layers","position":15},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"4) Workflow Modularity and Check Visibility","lvl2":"Target Design"},"type":"lvl3","url":"/v0-1-0-ci-container-redesign#id-4-workflow-modularity-and-check-visibility","position":16},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"4) Workflow Modularity and Check Visibility","lvl2":"Target Design"},"content":"Single CI workflow file (.github/workflows/ci.yml) for PR/push on main and develop.\n\nJob topology:\n\nprep: resolve fingerprint + image, restore image tar cache, emit outputs (runner job, no compile/test logic).\n\nbuild: compile once (make build-ci) and save cargo/sccache cache (runs inside the CI container image).\n\nParallel verify jobs (granular reviewer visibility):\n\nfmt -> make fmt-check (or cargo fmt --check)\n\nclippy -> make lint-clippy\n\ntest -> make test-ci (cargo nextest run)\n\nsmoke -> make smoke-test\n\nAll verify jobs:\n\nRun in the same fingerprinted CI container image as build.\n\nRestore caches read-only.\n\nAvoid duplicate compilation by relying on warmed cache from build.","type":"content","url":"/v0-1-0-ci-container-redesign#id-4-workflow-modularity-and-check-visibility","position":17},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"5) Test Tiering Policy","lvl2":"Target Design"},"type":"lvl3","url":"/v0-1-0-ci-container-redesign#id-5-test-tiering-policy","position":18},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"5) Test Tiering Policy","lvl2":"Target Design"},"content":"PR minimal gate:\n\nfmt, clippy, build-ci, nextest (default profile), smoke.\n\nPush to main/develop full verification:\n\nIncludes security/load/integration-heavy suites and packaging validation.\n\nImplementation note:\n\nEncode tiers as explicit make targets (test-pr, test-full) to keep local and CI behavior identical.","type":"content","url":"/v0-1-0-ci-container-redesign#id-5-test-tiering-policy","position":19},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"6) Local/CI Command Parity","lvl2":"Target Design"},"type":"lvl3","url":"/v0-1-0-ci-container-redesign#id-6-local-ci-command-parity","position":20},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"6) Local/CI Command Parity","lvl2":"Target Design"},"content":"Entrypoints:\n\nLocal: ./dflow ci-verify <target>\n\nCI: make <target> from inside container job\n\nRule:\n\nNo business logic in workflow YAML; logic lives in Makefile and src-scripts/.\n\nYAML only wires triggers, permissions, cache restore/save, and target invocation.","type":"content","url":"/v0-1-0-ci-container-redesign#id-6-local-ci-command-parity","position":21},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"7) Impact of Multi-Surface Refactor","lvl2":"Target Design"},"type":"lvl3","url":"/v0-1-0-ci-container-redesign#id-7-impact-of-multi-surface-refactor","position":22},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"7) Impact of Multi-Surface Refactor","lvl2":"Target Design"},"content":"If Kroki-rs adopts the multi-surface architecture (core/interface/transport/adapters), CI/container strategy should shift from a single-project pipeline to a contract-oriented workspace pipeline.\n\nChanges to consider:\n\nSplit CI targets by layer:\n\ncore (pure Rust, fastest checks)\n\ninterface/contracts (schema compatibility checks)\n\ntransport/adapters (HTTP, CLI, plugin integration checks)\n\nAdd contract compatibility gates:\n\nschema diff checks\n\nbackward-compatibility policy enforcement\n\ngenerated type/API conformance tests\n\nPartition caches by crate group and feature profile to avoid unnecessary invalidation.\n\nKeep one shared base CI image, but allow optional adapter extension images for stack-specific dependencies.","type":"content","url":"/v0-1-0-ci-container-redesign#id-7-impact-of-multi-surface-refactor","position":23},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"8) Generic Platform Model (Beyond This Repo)","lvl2":"Target Design"},"type":"lvl3","url":"/v0-1-0-ci-container-redesign#id-8-generic-platform-model-beyond-this-repo","position":24},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"8) Generic Platform Model (Beyond This Repo)","lvl2":"Target Design"},"content":"This proposal can be generalized into a reusable CI/dev orchestration model with stack extensions.\n\nPlatform core (generic):\n\nFingerprinted container identity\n\nStandard cache root contract\n\nCanonical command graph (setup/build/lint/test/package/release)\n\nProvider-agnostic check reporting and status mapping\n\nPolicy engine for PR gate tiers and branch protection contracts\n\nStack extensions (examples):\n\nRust:\n\ncargo, nextest, clippy, rustfmt, sccache\n\noptional workspace-aware cache slicing by crate\n\nNode.js/TypeScript:\n\npnpm/npm cache, lockfile-aware install, tsc --noEmit, eslint, vitest/jest\n\ncache keys include package manager + lockfile + Node version\n\nReact/Lit front-end:\n\nbuild/test/lint plus storybook/e2e extension gates\n\noptional browser test container profile\n\nVS Code extension:\n\nvsce packaging, extension host tests, API compatibility checks\n\nTauri:\n\nhost OS dependency profiles, frontend + Rust dual cache strategy, bundling/signing stages\n\nPrinciple:\n\nKeep 85-90% behavior in the core orchestrator; implement stack-specific logic as plugins/extensions.","type":"content","url":"/v0-1-0-ci-container-redesign#id-8-generic-platform-model-beyond-this-repo","position":25},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"9) Generic CLI Tool Design (Installable via Homebrew)","lvl2":"Target Design"},"type":"lvl3","url":"/v0-1-0-ci-container-redesign#id-9-generic-cli-tool-design-installable-via-homebrew","position":26},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"9) Generic CLI Tool Design (Installable via Homebrew)","lvl2":"Target Design"},"content":"Proposed tool concept: a standalone Rust CLI named devflow (alias dwf) that abstracts CI/container/caching complexity while preserving local developer UX.\n\nDesign goals:\n\nOne command surface across projects (devflow setup, devflow verify, devflow ci plan, devflow release).\n\nProject-level config with minimal required fields and optional extensions.\n\nDeterministic container-first workflows with portable local fallback.\n\nNative integration with GitHub Actions generation and validation.\n\nCanonical command interface:\n\nLong form: devflow <command>\n\nShort alias: dwf <command>\n\nExamples: dwf setup, dwf lint, dwf test, dwf verify, dwf ci generate\n\nHigh-level architecture:\n\ndevflow-core:\n\nDAG/task executor\n\ncache key builder\n\ncontainer resolver (local daemon, GHCR)\n\nstatus/check emitter abstraction\n\ndevflow-ext-*:\n\next-rust\n\next-node\n\next-frontend-react\n\next-frontend-lit\n\next-vscode\n\next-tauri\n\ndevflow-gh:\n\nworkflow templating, required-check contract generation, cache strategy synthesis\n\ndevflow-policy:\n\nbranch rules, PR gates, release constraints, environment matrix policy\n\nConfiguration model (example):[project]\nname = \"kroki-rs\"\nstack = [\"rust\"]\n\n[container]\nimage = \"ghcr.io/org/repo-ci\"\nfingerprint_inputs = [\"Dockerfile\", \"Makefile\", \"src-scripts/**\", \"rust-toolchain.toml\"]\n\n[cache]\nroot = \".cache/devflow\"\nstrategy = \"layered\"\n\n[targets]\npr = [\"fmt\", \"lint\", \"build\", \"test\"]\nmain = [\"fmt\", \"lint\", \"build\", \"test\", \"smoke\", \"security\"]\n\n[extensions.rust]\nfeatures = [\"native-browser\"]\ntest_runner = \"nextest\"\n\nCLI capabilities:\n\ninit: detect stack and scaffold config + make targets + workflow skeleton.\n\ndoctor: validate container engine, cache root permissions, toolchain drift.\n\nverify: run the canonical local containerized pipeline.\n\nci generate: generate/update GitHub Actions workflow from config.\n\ncache stats/prune: inspect and clean cache by scope/age.\n\npolicy check: ensure repo protections and required checks match config.\n\nCanonical command mapping by stack:\n\nCanonical command\n\nRust stack\n\nNode/TypeScript (pnpm)\n\nReact/Lit frontend\n\nVS Code extension\n\nTauri\n\ndwf setup\n\nrustup show, toolchain sync, container/image resolve\n\npnpm install --frozen-lockfile\n\npnpm install --frozen-lockfile\n\npnpm install --frozen-lockfile\n\nRust + pnpm install + platform deps check\n\ndwf fmt\n\ncargo fmt --all\n\npnpm prettier -w . (or repo formatter)\n\npnpm prettier -w .\n\npnpm prettier -w .\n\ncargo fmt --all + frontend formatter\n\ndwf fmt-check\n\ncargo fmt --all -- --check\n\npnpm prettier -c .\n\npnpm prettier -c .\n\npnpm prettier -c .\n\ncargo fmt --all -- --check + frontend fmt check\n\ndwf lint\n\ncargo clippy --all-targets -- -D warnings\n\npnpm eslint . + pnpm tsc --noEmit\n\npnpm eslint . + typecheck\n\npnpm eslint . + extension typecheck\n\nRust clippy + frontend eslint/typecheck\n\ndwf build\n\ncargo build --release\n\npnpm build\n\npnpm build\n\npnpm package / extension bundle\n\ncargo build --release + frontend build\n\ndwf test\n\ncargo nextest run\n\npnpm test (vitest/jest)\n\npnpm test\n\nextension host tests\n\ncargo nextest run + frontend tests\n\ndwf smoke\n\napp health/CLI smoke script\n\napp startup + HTTP smoke\n\npreview/build smoke\n\ninstall/package smoke\n\napp startup/bundle smoke\n\ndwf verify\n\nfmt-check + lint + build + test + smoke\n\nsame canonical sequence mapped to JS toolchain\n\nsame canonical sequence\n\nsame canonical sequence\n\nsame canonical sequence\n\ndwf ci generate\n\ngenerate Rust-oriented CI jobs/cache keys\n\ngenerate pnpm/node CI jobs/cache keys\n\nadd frontend/e2e job templates\n\nadd extension packaging jobs\n\nadd OS matrix + bundling/signing jobs\n\nNotes:\n\nThe canonical command names are stable for developers; stack-specific executors are resolved from config extensions.\n\ndwf verify should always run inside the configured fingerprinted container in CI, and optionally locally via containerized mode.\n\nRollout path for this project:\n\nPhase A: treat current dflow as compatibility facade and map it to devflow/dwf commands.\n\nPhase B: move cache/image/check contracts into typed config.\n\nPhase C: keep project-specific extensions only for diagram-tool dependencies and release packaging nuances.","type":"content","url":"/v0-1-0-ci-container-redesign#id-9-generic-cli-tool-design-installable-via-homebrew","position":27},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl2":"Required Repo Changes"},"type":"lvl2","url":"/v0-1-0-ci-container-redesign#required-repo-changes","position":28},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl2":"Required Repo Changes"},"content":"Standardize fingerprint algorithm docs + scripts to one input set.\n\nIntroduce KROKI_CACHE_ROOT and replace hardcoded .cargo-cache/target/ci paths in scripts and make fragments.\n\nAdd explicit CI-tier targets:\n\nfmt-check\n\nlint-clippy\n\ntest-pr\n\ntest-full\n\nConsolidate CI triggers into one workflow (main, develop) and keep release/package workflows separate.\n\nAdd cache key normalization helper (script or make target) reused by both local diagnostics and GHA.\n\nAdd CI observability summary:\n\nfingerprint used\n\ncache hit/miss stats\n\nsccache hit ratio per run\n\nAdd explicit note in workflow docs that build and all verify-* jobs execute in the fingerprinted CI container.\n\nAdd extension points in docs/config for future multi-surface and multi-stack orchestration.","type":"content","url":"/v0-1-0-ci-container-redesign#required-repo-changes","position":29},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl2":"Suggested Implementation Plan (v0.1.0)"},"type":"lvl2","url":"/v0-1-0-ci-container-redesign#suggested-implementation-plan-v0-1-0","position":30},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl2":"Suggested Implementation Plan (v0.1.0)"},"content":"","type":"content","url":"/v0-1-0-ci-container-redesign#suggested-implementation-plan-v0-1-0","position":31},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"Phase 1: Cache Contract and Fingerprint Consistency","lvl2":"Suggested Implementation Plan (v0.1.0)"},"type":"lvl3","url":"/v0-1-0-ci-container-redesign#phase-1-cache-contract-and-fingerprint-consistency","position":32},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"Phase 1: Cache Contract and Fingerprint Consistency","lvl2":"Suggested Implementation Plan (v0.1.0)"},"content":"Add KROKI_CACHE_ROOT contract and migrate mounts/env vars.\n\nAlign fingerprint implementation and documentation.\n\nValidate no regression in ./dflow ci-verify.","type":"content","url":"/v0-1-0-ci-container-redesign#phase-1-cache-contract-and-fingerprint-consistency","position":33},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"Phase 2: CI Job Contract Refactor","lvl2":"Suggested Implementation Plan (v0.1.0)"},"type":"lvl3","url":"/v0-1-0-ci-container-redesign#phase-2-ci-job-contract-refactor","position":34},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"Phase 2: CI Job Contract Refactor","lvl2":"Suggested Implementation Plan (v0.1.0)"},"content":"Create/adjust make targets for granular checks.\n\nRefactor CI workflow into prep/build/parallel-verify jobs.\n\nKeep required checks mapped to the same stable names.","type":"content","url":"/v0-1-0-ci-container-redesign#phase-2-ci-job-contract-refactor","position":35},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"Phase 3: Test Tiering + Runtime Optimization","lvl2":"Suggested Implementation Plan (v0.1.0)"},"type":"lvl3","url":"/v0-1-0-ci-container-redesign#phase-3-test-tiering-runtime-optimization","position":36},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"Phase 3: Test Tiering + Runtime Optimization","lvl2":"Suggested Implementation Plan (v0.1.0)"},"content":"Formalize PR vs full test tiers.\n\nTune nextest profile and retries for flaky integration suites.\n\nAdd run summaries with cache and compile diagnostics.","type":"content","url":"/v0-1-0-ci-container-redesign#phase-3-test-tiering-runtime-optimization","position":37},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"Phase 4: Hardening (Optional, Recommended)","lvl2":"Suggested Implementation Plan (v0.1.0)"},"type":"lvl3","url":"/v0-1-0-ci-container-redesign#phase-4-hardening-optional-recommended","position":38},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl3":"Phase 4: Hardening (Optional, Recommended)","lvl2":"Suggested Implementation Plan (v0.1.0)"},"content":"Add SBOM + image scan gates.\n\nAdd provenance/signing for release images.\n\nAdd periodic cache hygiene workflow.","type":"content","url":"/v0-1-0-ci-container-redesign#phase-4-hardening-optional-recommended","position":39},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl2":"Risks and Mitigations"},"type":"lvl2","url":"/v0-1-0-ci-container-redesign#risks-and-mitigations","position":40},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl2":"Risks and Mitigations"},"content":"Risk: over-broad target cache reuse can cause stale artifacts.\n\nMitigation: include fingerprint + toolchain + feature mode in cache key.\n\nRisk: too many parallel jobs increase image pull overhead.\n\nMitigation: keep verify jobs lightweight and rely on prep/build warm cache.\n\nRisk: local cache growth on macOS.\n\nMitigation: configurable cache root + retention/prune targets.","type":"content","url":"/v0-1-0-ci-container-redesign#risks-and-mitigations","position":41},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl2":"Decision Notes on Requested Strategies"},"type":"lvl2","url":"/v0-1-0-ci-container-redesign#decision-notes-on-requested-strategies","position":42},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl2":"Decision Notes on Requested Strategies"},"content":"Mounting cargo registry/git/target caches is correct and should remain, with stronger key scoping and a configurable root.\n\ncargo nextest is the right default for CI; keep it as the primary PR test executor.\n\nGranular checks should remain visible as separate required statuses/check-runs.\n\nSingle CI workflow for PR/push on main and develop is recommended; keep release/publish workflows independent.","type":"content","url":"/v0-1-0-ci-container-redesign#decision-notes-on-requested-strategies","position":43},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl2":"Success Criteria"},"type":"lvl2","url":"/v0-1-0-ci-container-redesign#success-criteria","position":44},{"hierarchy":{"lvl1":"v0.1.0 CI/Container Redesign Proposal","lvl2":"Success Criteria"},"content":"Local ./dflow ci-verify and PR CI run identical targets in the same image identity.\n\nWarm PR rerun latency significantly lower than cold runs, with measurable sccache and cache hit ratios.\n\nReviewers can identify failure domain immediately from independent check status names.\n\nPipeline logic remains modular and centralized in scripts/make targets, not duplicated in YAML.","type":"content","url":"/v0-1-0-ci-container-redesign#success-criteria","position":45},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review"},"type":"lvl1","url":"/v0-1-0-critical-review","position":0},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review"},"content":"","type":"content","url":"/v0-1-0-critical-review","position":1},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl2":"1. Review Summary"},"type":"lvl2","url":"/v0-1-0-critical-review#id-1-review-summary","position":2},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl2":"1. Review Summary"},"content":"This is the second revision of the critical review, updated after substantial implementation\nchanges that addressed several findings from revision 1.\n\nThe project has moved from a documentation-only state to a functional walking skeleton.\nCommands now execute real processes, target profiles are dynamic, the GH Actions renderer\ngenerates proper multi-job topologies, config validation rejects invalid inputs, and the\nextension crates are no longer dead code. This is significant progress.\n\nThe remaining concerns have shifted from “nothing works” to “the execution model has\narchitectural misplacement and the doc-code contract still has gaps.” These are solvable\nat this stage but will calcify if deferred.\n\nSeverity ratings:\n\nCritical: blocks correctness or viability of the v0.1.0 design.\n\nMajor: creates substantial rework risk or undermines stated goals.\n\nMinor: worth addressing but does not block progress.\n\nResolved: addressed since revision 1.","type":"content","url":"/v0-1-0-critical-review#id-1-review-summary","position":3},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl2":"2. Resolved Findings"},"type":"lvl2","url":"/v0-1-0-critical-review#id-2-resolved-findings","position":4},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl2":"2. Resolved Findings"},"content":"","type":"content","url":"/v0-1-0-critical-review#id-2-resolved-findings","position":5},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"2.1 Execution Engine Now Exists","lvl2":"2. Resolved Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-2-1-execution-engine-now-exists","position":6},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"2.1 Execution Engine Now Exists","lvl2":"2. Resolved Findings"},"content":"Previous severity: Critical | Status: Resolved\n\nThe new executor.rs module in devflow-cli spawns real processes via\nstd::process::Command. It resolves stacks from config, detects project manifests\n(Cargo.toml, package.json), maps canonical commands to toolchain-specific argv\nvectors, and propagates exit codes. dwf fmt:check now actually runs\ncargo fmt --all -- --check. This is the walking skeleton that was recommended.","type":"content","url":"/v0-1-0-critical-review#id-2-1-execution-engine-now-exists","position":7},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"2.2 Extension Crates Are No Longer Dead Code","lvl2":"2. Resolved Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-2-2-extension-crates-are-no-longer-dead-code","position":8},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"2.2 Extension Crates Are No Longer Dead Code","lvl2":"2. Resolved Findings"},"content":"Previous severity: Critical | Status: Resolved\n\ndevflow-core/Cargo.toml now depends on devflow-ext-rust and devflow-ext-node.\nThe builtin_capabilities() function in extension.rs calls into these crates when\nconfig does not declare explicit capabilities. The extension crates now serve a concrete\npurpose in the dependency graph.","type":"content","url":"/v0-1-0-critical-review#id-2-2-extension-crates-are-no-longer-dead-code","position":9},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"2.3 Target Profiles Are Dynamic","lvl2":"2. Resolved Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-2-3-target-profiles-are-dynamic","position":10},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"2.3 Target Profiles Are Dynamic","lvl2":"2. Resolved Findings"},"content":"Previous severity: Major | Status: Resolved\n\nTargetsConfig now uses HashMap<String, Vec<String>> with #[serde(flatten)]. The\npolicy resolver uses .get(selector) instead of a hardcoded match. Custom profiles like\ndevelop, staging, or hotfix work without code changes. The architecture doc was\nupdated to document this as “dynamic map keys.” Clean fix.","type":"content","url":"/v0-1-0-critical-review#id-2-3-target-profiles-are-dynamic","position":11},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"2.4 GH Actions Renderer Generates Real Workflows","lvl2":"2. Resolved Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-2-4-gh-actions-renderer-generates-real-workflows","position":12},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"2.4 GH Actions Renderer Generates Real Workflows","lvl2":"2. Resolved Findings"},"content":"Previous severity: Major | Status: Resolved\n\nrender_workflow now generates prep/build/parallel-check topology from the pr target\nprofile. check_workflow validates rendered output against expected structure. The\nsanitize_job_name helper handles special characters. Three tests cover the render and\nvalidation paths. This is a substantive improvement.","type":"content","url":"/v0-1-0-critical-review#id-2-4-gh-actions-renderer-generates-real-workflows","position":13},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"2.5 Config Validation Exists","lvl2":"2. Resolved Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-2-5-config-validation-exists","position":14},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"2.5 Config Validation Exists","lvl2":"2. Resolved Findings"},"content":"Previous severity: Minor | Status: Resolved\n\nDevflowConfig now uses #[serde(deny_unknown_fields)] on key structs. A validate()\nmethod checks stack names against known values and parses all target command references\nat load time. Unknown top-level keys, unknown project keys, and invalid command strings\nin target profiles all fail fast with actionable errors. Two new tests cover rejection\npaths.","type":"content","url":"/v0-1-0-critical-review#id-2-5-config-validation-exists","position":15},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"2.6 Extension Target Validation","lvl2":"2. Resolved Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-2-6-extension-target-validation","position":16},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"2.6 Extension Target Validation","lvl2":"2. Resolved Findings"},"content":"Previous severity: Minor (selector validation) | Status: Partially resolved\n\nExtensionRegistry::validate_target_support now validates that every command in every\ntarget profile is covered by at least one extension’s capabilities. This runs at startup,\ncatching typos like test:untit before any execution attempt. Two new tests cover this\npath. The remaining gap: arbitrary selectors still parse successfully at the CommandRef\nlevel; validation depends on the extension registry being populated.","type":"content","url":"/v0-1-0-critical-review#id-2-6-extension-target-validation","position":17},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"2.7 Test Coverage Improved","lvl2":"2. Resolved Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-2-7-test-coverage-improved","position":18},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"2.7 Test Coverage Improved","lvl2":"2. Resolved Findings"},"content":"Previous severity: Minor | Status: Partially resolved\n\nTest count has increased from 4 to approximately 10, now covering config rejection,\nextension target validation, workflow rendering, and workflow checking. Key gaps remain\n(see Section 4.4).","type":"content","url":"/v0-1-0-critical-review#id-2-7-test-coverage-improved","position":19},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl2":"3. Critical Findings"},"type":"lvl2","url":"/v0-1-0-critical-review#id-3-critical-findings","position":20},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl2":"3. Critical Findings"},"content":"","type":"content","url":"/v0-1-0-critical-review#id-3-critical-findings","position":21},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"3.1 Command-to-Toolchain Mapping Lives in the Wrong Layer","lvl2":"3. Critical Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-3-1-command-to-toolchain-mapping-lives-in-the-wrong-layer","position":22},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"3.1 Command-to-Toolchain Mapping Lives in the Wrong Layer","lvl2":"3. Critical Findings"},"content":"Previous severity: Critical | Status: Resolved\n\nThe architecture states that extensions “map canonical commands to executable actions”\n(Section 10) and that “stack-specific logic lives in devflow-ext-*” (Section 3).\nThis was originally implemented backwards, with mapping in devflow-cli.\n\nThis has been RESOLVED via Phase 1 and Phase 2. The Extension trait was introduced, devflow-core drops all specific platform dependencies, and command mappings were moved into devflow-ext-rust and devflow-ext-node. Furthermore, devflow-cli now dynamically probes $PATH for devflow-ext-* subprocess extensions, mapping capabilities instantly without recompilation via JSON over stdio.","type":"content","url":"/v0-1-0-critical-review#id-3-1-command-to-toolchain-mapping-lives-in-the-wrong-layer","position":23},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"3.2 Architecture Document Schema Contradicts deny_unknown_fields","lvl2":"3. Critical Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-3-2-architecture-document-schema-contradicts-deny-unknown-fields","position":24},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"3.2 Architecture Document Schema Contradicts deny_unknown_fields","lvl2":"3. Critical Findings"},"content":"Severity: Critical\n\nThe architecture document (Section 6) shows this as the minimum config schema:[container]\nimage = \"ghcr.io/org/repo-ci\"\nfingerprint_inputs = [\"Dockerfile\", \"Makefile\", ...]\n\n[cache]\nroot = \".cache/devflow\"\nstrategy = \"layered\"\n\nBut DevflowConfig now uses #[serde(deny_unknown_fields)]. Any user who copies the\ndocumented schema will get a parse error because [container] and [cache] are unknown\nfields. The document promises a config contract that the implementation actively rejects.\n\nThis is worse than the drift in revision 1 because the validation is now stricter. Before,\nunknown keys were silently accepted; now they are hard errors, making the documented schema\na guaranteed failure path.\n\nRecommendation: Either remove [container] and [cache] from the architecture\ndocument’s schema example (marking them as planned for a future version), or add\nplaceholder structs with #[serde(default)] so the keys are accepted without\nimplementation. Do not document fields that the parser rejects.","type":"content","url":"/v0-1-0-critical-review#id-3-2-architecture-document-schema-contradicts-deny-unknown-fields","position":25},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl2":"4. Major Findings"},"type":"lvl2","url":"/v0-1-0-critical-review#id-4-major-findings","position":26},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl2":"4. Major Findings"},"content":"","type":"content","url":"/v0-1-0-critical-review#id-4-major-findings","position":27},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"4.1 ci:check Validates Its Own Output, Not the Committed Workflow","lvl2":"4. Major Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-4-1-ci-check-validates-its-own-output-not-the-committed-workflow","position":28},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"4.1 ci:check Validates Its Own Output, Not the Committed Workflow","lvl2":"4. Major Findings"},"content":"Severity: Major\n\nThe ci:check command in main.rs:77-82 does this:PrimaryCommand::Ci if command.selector.as_deref() == Some(\"check\") => {\n    let workflow = devflow_gh::render_workflow(cfg)?;\n    devflow_gh::check_workflow(cfg, &workflow)?;\n    println!(\"ci:check passed\");\n    Ok(())\n}\n\nIt renders a workflow from config, then validates that same rendered output. This is a\ntautology: ci:check will always pass because it is checking the renderer’s output\nagainst the renderer’s own expectations. The useful check would be to read the committed\n.github/workflows/ci.yml from disk and validate it against the config, detecting\nwhen the committed workflow has drifted from what ci:generate would produce.\n\nRecommendation: ci:check should read the workflow file from disk (defaulting to\n--ci-output path) and validate that against the config. The current implementation\nshould be renamed to something like ci:validate-render or removed, since a self-check\nprovides no signal.","type":"content","url":"/v0-1-0-critical-review#id-4-1-ci-check-validates-its-own-output-not-the-committed-workflow","position":29},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"4.2 Rust Test Selectors Have Overlapping Scope","lvl2":"4. Major Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-4-2-rust-test-selectors-have-overlapping-scope","position":30},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"4.2 Rust Test Selectors Have Overlapping Scope","lvl2":"4. Major Findings"},"content":"Severity: Major\n\nThe test command mappings in executor.rs are:(PrimaryCommand::Test, \"unit\") => Some(vec![\"cargo\", \"test\", \"--lib\", \"--bins\"]),\n(PrimaryCommand::Test, \"integration\") => Some(vec![\"cargo\", \"test\", \"--tests\"]),\n\ncargo test --tests runs all targets in the tests/ directory and #[test]\nfunctions in --lib and --bins. This means test:integration re-runs all unit tests.\nThe --tests flag in Cargo means “run test targets” (the [[test]] sections), but it\nalso includes lib and bin test targets by default.\n\nA PR target of [\"test:unit\", \"test:integration\"] will execute unit tests twice. For a\nproject with a large test suite, this doubles CI time for no benefit.\n\nRecommendation: Use cargo test --test '*' for integration (runs only files in\ntests/ directory) or cargo nextest run --partition-by=test-type if adopting nextest\nas the architecture document’s CI redesign proposes.","type":"content","url":"/v0-1-0-critical-review#id-4-2-rust-test-selectors-have-overlapping-scope","position":31},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"4.3 Bootstrapping Paradox Remains Unaddressed","lvl2":"4. Major Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-4-3-bootstrapping-paradox-remains-unaddressed","position":32},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"4.3 Bootstrapping Paradox Remains Unaddressed","lvl2":"4. Major Findings"},"content":"Severity: Major\n\nThis finding is unchanged from revision 1. devflow uses devflow.toml to configure\nits own build. The Makefile compiles the CLI before running it. CI must build devflow-cli\nbefore it can use it. No documentation addresses what must exist before dwf runs.\n\nThe generated .github/workflows/ci.yml references dwf build:debug and dwf <command>\nbut does not include a step to install dwf. A CI runner executing this workflow will fail\nat the first dwf invocation.\n\nRecommendation: The generated workflow must include either a dwf installation step\n(e.g., cargo install or download from releases) or fall back to\ncargo run -p devflow-cli --. Document the bootstrap prerequisites explicitly.","type":"content","url":"/v0-1-0-critical-review#id-4-3-bootstrapping-paradox-remains-unaddressed","position":33},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"4.4 Executor Has No Tests","lvl2":"4. Major Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-4-4-executor-has-no-tests","position":34},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"4.4 Executor Has No Tests","lvl2":"4. Major Findings"},"content":"Severity: Major\n\nexecutor.rs is the most consequential module in the project --- it is the only code that\nactually does work. It has zero tests. The following behaviors are untested:\n\nStack resolution from config\n\nManifest detection (stack_is_applicable)\n\nDefault selector assignment (with_default_selector)\n\nCommand mapping for Rust (14 match arms)\n\nCommand mapping for Node (11 match arms)\n\nBehavior when no stack matches\n\nBehavior when stack manifest is missing\n\nProcess exit code propagation\n\nThe command mapping functions are pure (input to output, no side effects) and trivially\ntestable. The manifest detection could be tested with a temp directory.\n\nRecommendation: Add unit tests for map_rust, map_node, with_default_selector,\nand resolve_stacks at minimum. These are the highest-value tests in the entire project.","type":"content","url":"/v0-1-0-critical-review#id-4-4-executor-has-no-tests","position":35},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl2":"5. Minor Findings"},"type":"lvl2","url":"/v0-1-0-critical-review#id-5-minor-findings","position":36},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl2":"5. Minor Findings"},"content":"","type":"content","url":"/v0-1-0-critical-review#id-5-minor-findings","position":37},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"5.1 Implicit Default in check Command","lvl2":"5. Minor Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-5-1-implicit-default-in-check-command","position":38},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"5.1 Implicit Default in check Command","lvl2":"5. Minor Findings"},"content":"Status: Still open from revision 1\n\ncheck without a selector still defaults silently to check:pr (main.rs:57). This\nmay surprise users who expect check alone to require an explicit selector. All other\nprimary commands get defaults via with_default_selector, but check is handled\nseparately in the execute match, creating an inconsistency in how defaults are applied.","type":"content","url":"/v0-1-0-critical-review#id-5-1-implicit-default-in-check-command","position":39},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"5.2 Dual CLI Syntax Creates Ambiguity","lvl2":"5. Minor Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-5-2-dual-cli-syntax-creates-ambiguity","position":40},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"5.2 Dual CLI Syntax Creates Ambiguity","lvl2":"5. Minor Findings"},"content":"Status: Still open from revision 1\n\nBoth dwf test:unit and dwf test unit work. The space syntax concatenates positional\narguments. Three-word invocations (dwf ci generate foo) silently drop extra arguments.\nNo validation ensures completeness.","type":"content","url":"/v0-1-0-critical-review#id-5-2-dual-cli-syntax-creates-ambiguity","position":41},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"5.3 Legacy Naming Artifacts","lvl2":"5. Minor Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-5-3-legacy-naming-artifacts","position":42},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"5.3 Legacy Naming Artifacts","lvl2":"5. Minor Findings"},"content":"Status: Still open from revision 1\n\nv0.1.0-ci-container-redesign.md still references KROKI_CACHE_ROOT, kroki-rs, and\n./dflow. The label uses kroki-rs.developer-guide.* instead of devflow.*.","type":"content","url":"/v0-1-0-critical-review#id-5-3-legacy-naming-artifacts","position":43},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"5.4 devflow.toml Declares Node Stack With No Node Project","lvl2":"5. Minor Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-5-4-devflow-toml-declares-node-stack-with-no-node-project","position":44},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"5.4 devflow.toml Declares Node Stack With No Node Project","lvl2":"5. Minor Findings"},"content":"The project’s own devflow.toml declares stack = [\"rust\", \"node\"] but there is no\npackage.json in the repository. Every command execution will print\n“skip node: manifest not found”. This is noisy and misleading for anyone running\nthe project’s own workflow. Either add a minimal package.json or remove \"node\"\nfrom the stack list.","type":"content","url":"/v0-1-0-critical-review#id-5-4-devflow-toml-declares-node-stack-with-no-node-project","position":45},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"5.5 stack_is_applicable Uses Relative Paths","lvl2":"5. Minor Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-5-5-stack-is-applicable-uses-relative-paths","position":46},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"5.5 stack_is_applicable Uses Relative Paths","lvl2":"5. Minor Findings"},"content":"Path::new(\"Cargo.toml\").exists() depends on the current working directory. If a user\nruns dwf fmt:check from a subdirectory or with --config /other/path/devflow.toml,\nthe manifest check will fail even though the project root has a Cargo.toml. There is\nno project root resolution.\n\nRecommendation: Derive the project root from the config file path and resolve\nmanifests relative to that root.","type":"content","url":"/v0-1-0-critical-review#id-5-5-stack-is-applicable-uses-relative-paths","position":47},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"5.6 Node Stack Hardcodes npm","lvl2":"5. Minor Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-5-6-node-stack-hardcodes-npm","position":48},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"5.6 Node Stack Hardcodes npm","lvl2":"5. Minor Findings"},"content":"All Node command mappings use npm (npm ci, npm run fmt:check, etc.). The CI redesign\ndocument extensively references pnpm. There is no detection of pnpm/yarn via lockfile\npresence, no config option to select a package manager, and no environment variable override.","type":"content","url":"/v0-1-0-critical-review#id-5-6-node-stack-hardcodes-npm","position":49},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"5.7 with_default_selector Maps setup to doctor","lvl2":"5. Minor Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-5-7-with-default-selector-maps-setup-to-doctor","position":50},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"5.7 with_default_selector Maps setup to doctor","lvl2":"5. Minor Findings"},"content":"setup intuitively means “set things up” (install toolchains, sync dependencies).\nMapping bare setup to setup:doctor (which runs cargo --version or npm --version)\nis surprising. A user running dwf setup expecting environment preparation will instead\nget a version check.","type":"content","url":"/v0-1-0-critical-review#id-5-7-with-default-selector-maps-setup-to-doctor","position":51},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"5.8 Hardcoded &'static str Argv Prevents Configuration","lvl2":"5. Minor Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-5-8-hardcoded-static-str-argv-prevents-configuration","position":52},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"5.8 Hardcoded &'static str Argv Prevents Configuration","lvl2":"5. Minor Findings"},"content":"Command mappings return Vec<&'static str>. This means:\n\nUsers cannot pass extra flags (e.g., --workspace to cargo commands).\n\ncargo clippy always uses --all-features, which may not be desired.\n\ncargo test cannot target specific test names or use nextest.\n\nNo config-driven overrides for any toolchain invocation.\n\nThis is acceptable for a v0.1.0 walking skeleton but will be the first friction point\nfor real-world adoption.","type":"content","url":"/v0-1-0-critical-review#id-5-8-hardcoded-static-str-argv-prevents-configuration","position":53},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"5.9 Makefile Remains a Thin Wrapper","lvl2":"5. Minor Findings"},"type":"lvl3","url":"/v0-1-0-critical-review#id-5-9-makefile-remains-a-thin-wrapper","position":54},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"5.9 Makefile Remains a Thin Wrapper","lvl2":"5. Minor Findings"},"content":"Status: Still open from revision 1\n\nEvery Makefile target is still cargo run -p devflow-cli -- <command> with no added value.","type":"content","url":"/v0-1-0-critical-review#id-5-9-makefile-remains-a-thin-wrapper","position":55},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl2":"6. Structural Observations"},"type":"lvl2","url":"/v0-1-0-critical-review#id-6-structural-observations","position":56},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl2":"6. Structural Observations"},"content":"","type":"content","url":"/v0-1-0-critical-review#id-6-structural-observations","position":57},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"6.1 Crate Decomposition Is More Justified Now","lvl2":"6. Structural Observations"},"type":"lvl3","url":"/v0-1-0-critical-review#id-6-1-crate-decomposition-is-more-justified-now","position":58},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"6.1 Crate Decomposition Is More Justified Now","lvl2":"6. Structural Observations"},"content":"Revision 1 flagged 6 crates for ~350 lines as premature. The codebase has grown:\ndevflow-gh is now ~95 lines with 3 tests, executor.rs is ~179 lines, and\nextension.rs has ~130 lines with tests. While some crates remain small\n(devflow-ext-node: 17 lines, devflow-ext-rust: 18 lines), the overall structure\nis more proportionate. The extension crates will need to grow significantly once the\ncommand mapping moves into them (per finding 3.1).","type":"content","url":"/v0-1-0-critical-review#id-6-1-crate-decomposition-is-more-justified-now","position":59},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"6.2 The Extension Trait Decision Remains the Central Open Question","lvl2":"6. Structural Observations"},"type":"lvl3","url":"/v0-1-0-critical-review#id-6-2-the-extension-trait-decision-remains-the-central-open-question","position":60},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"6.2 The Extension Trait Decision Remains the Central Open Question","lvl2":"6. Structural Observations"},"content":"Status: Resolved\n\nThe most consequential unresolved design decision was how extensions execute commands.\nThis has been completely RESOLVED by implementing a hybrid approach:\n\nTrait objects in core: trait Extension { fn map_command(&self, cmd) -> Argv; } is implemented by devflow-ext-rust and devflow-ext-node, delivering extreme performance for default stacks.\n\nSubprocess delegation: For other capabilities (like python or go), the system automatically discovers binaries prefixed with devflow-ext- in the $PATH at boot, communicating with them seamlessly via JSON over stdio.","type":"content","url":"/v0-1-0-critical-review#id-6-2-the-extension-trait-decision-remains-the-central-open-question","position":61},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl2":"7. What Works Well"},"type":"lvl2","url":"/v0-1-0-critical-review#id-7-what-works-well","position":62},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl2":"7. What Works Well"},"content":"Strengths carried forward from revision 1, reinforced by changes:\n\nThe primary/secondary command model remains well-designed and is now validated\nend-to-end. The command:selector syntax works in practice, not just in docs.\n\nPolicy-driven composition now works with dynamic profiles. check:staging or\ncheck:hotfix are trivially addable via config.\n\nConfig validation is strict and early. deny_unknown_fields plus the validate()\nmethod catches errors at load time. This is the right posture for a tool that generates\nCI workflows.\n\nThe GH renderer now produces useful output. Prep/build/parallel-check topology\nmatches the architecture, and the check_workflow validator creates a contract between\nrender and verify. The round-trip test (render then check) is a good pattern.\n\nThe executor is clean and extensible. run_argv is simple, map_command dispatch\nis straightforward, and the stack-applicability check (manifest detection) is a pragmatic\nheuristic. The module is well-structured for future growth.\n\nThe walking skeleton validates the architecture. The fact that dwf fmt:check\nactually runs cargo fmt --check proves the config-to-execution pipeline works.\nThis is the most important change since revision 1.","type":"content","url":"/v0-1-0-critical-review#id-7-what-works-well","position":63},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl2":"8. Recommendations (Updated and Reprioritized)"},"type":"lvl2","url":"/v0-1-0-critical-review#id-8-recommendations-updated-and-reprioritized","position":64},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl2":"8. Recommendations (Updated and Reprioritized)"},"content":"","type":"content","url":"/v0-1-0-critical-review#id-8-recommendations-updated-and-reprioritized","position":65},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"Immediate (before further feature work)","lvl2":"8. Recommendations (Updated and Reprioritized)"},"type":"lvl3","url":"/v0-1-0-critical-review#immediate-before-further-feature-work","position":66},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"Immediate (before further feature work)","lvl2":"8. Recommendations (Updated and Reprioritized)"},"content":"Move command mapping into extension crates. This is the highest-priority structural\nfix. map_rust belongs in devflow-ext-rust, not in devflow-cli. Define a minimal\ntrait or function signature that extensions implement, even if dispatch remains static.\n\nFix the doc schema. Remove [container] and [cache] from the Section 6 example\nor add them as accepted-but-unused fields. The documented schema must parse successfully.\n\nFix ci:check to read committed workflow. It should validate the file on disk,\nnot the renderer’s own output.\n\nFix Rust test scope overlap. test:integration should not re-run unit tests.","type":"content","url":"/v0-1-0-critical-review#immediate-before-further-feature-work","position":67},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"Short-term (during v0.1.0)","lvl2":"8. Recommendations (Updated and Reprioritized)"},"type":"lvl3","url":"/v0-1-0-critical-review#short-term-during-v0-1-0","position":68},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"Short-term (during v0.1.0)","lvl2":"8. Recommendations (Updated and Reprioritized)"},"content":"Add executor tests. map_rust, map_node, with_default_selector, and\nresolve_stacks are pure functions that should have full test coverage.\n\nAdd dwf installation step to generated CI. The workflow is unusable without it.\n\nResolve project root for manifest detection. Use the config file location as anchor.\n\nRemove \"node\" from the project’s own devflow.toml or add a package.json.","type":"content","url":"/v0-1-0-critical-review#short-term-during-v0-1-0","position":69},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"Medium-term (v0.1.0 completion)","lvl2":"8. Recommendations (Updated and Reprioritized)"},"type":"lvl3","url":"/v0-1-0-critical-review#medium-term-v0-1-0-completion","position":70},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl3":"Medium-term (v0.1.0 completion)","lvl2":"8. Recommendations (Updated and Reprioritized)"},"content":"Define the Extension trait. Even a minimal fn map_command(&self, cmd: &CommandRef) -> Option<Vec<String>> would formalize the contract.\n\nAdd config-driven command overrides. Allow extensions to accept extra args or\nalternative binaries (e.g., pnpm vs npm, nextest vs cargo test).\n\nClean up legacy references. The CI redesign doc still carries kroki-rs naming.\n\nDocument bootstrap prerequisites. What must exist before dwf can run.","type":"content","url":"/v0-1-0-critical-review#medium-term-v0-1-0-completion","position":71},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl2":"9. Conclusion"},"type":"lvl2","url":"/v0-1-0-critical-review#id-9-conclusion","position":72},{"hierarchy":{"lvl1":"v0.1.0 Critical Architecture and Implementation Review","lvl2":"9. Conclusion"},"content":"The project has made strong progress between revisions. The gap between architecture and\nimplementation has narrowed substantially: commands execute, config validates, workflows\ngenerate, and extensions participate in the dependency graph. The walking skeleton exists\nand works.\n\nThe remaining critical issue is structural: command-to-toolchain mapping is in the CLI\nrather than in extension crates, which violates the documented architecture and will make\nadding new stacks painful. The doc-code schema contradiction is a close second --- it is\na trust issue for anyone adopting the tool.\n\nThe path forward is clear: move execution logic into extensions, align the documented\nconfig schema with what the parser accepts, and add tests for the executor. These are\nbounded, well-defined tasks that strengthen the foundation without requiring architectural\nrethinking.\n\nThe project is in a meaningfully better position than at revision 1. It has graduated from\n“specification without validation” to “working system with known structural debts.” That is\nthe right trajectory for a v0.1.0.","type":"content","url":"/v0-1-0-critical-review#id-9-conclusion","position":73},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan"},"type":"lvl1","url":"/v0-1-0-implementation-execution-plan","position":0},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan"},"content":"","type":"content","url":"/v0-1-0-implementation-execution-plan","position":1},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl2":"Goal"},"type":"lvl2","url":"/v0-1-0-implementation-execution-plan#goal","position":2},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl2":"Goal"},"content":"Provide executable, phase-gated implementation details for:\n\ndevflow platform delivery as a reusable CLI.\n\nkroki-rs-nxt bootstrap and migration using devflow.","type":"content","url":"/v0-1-0-implementation-execution-plan#goal","position":3},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl2":"Repo Launch Sequence"},"type":"lvl2","url":"/v0-1-0-implementation-execution-plan#repo-launch-sequence","position":4},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl2":"Repo Launch Sequence"},"content":"Create devflow repository.\n\nCreate kroki-rs-nxt repository.\n\nKeep kroki-rs in maintenance mode for bug fixes and critical releases only.","type":"content","url":"/v0-1-0-implementation-execution-plan#repo-launch-sequence","position":5},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl2":"Workstream A: devflow (Platform)"},"type":"lvl2","url":"/v0-1-0-implementation-execution-plan#workstream-a-devflow-platform","position":6},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl2":"Workstream A: devflow (Platform)"},"content":"","type":"content","url":"/v0-1-0-implementation-execution-plan#workstream-a-devflow-platform","position":7},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl3":"A0 Governance and Scope","lvl2":"Workstream A: devflow (Platform)"},"type":"lvl3","url":"/v0-1-0-implementation-execution-plan#a0-governance-and-scope","position":8},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl3":"A0 Governance and Scope","lvl2":"Workstream A: devflow (Platform)"},"content":"Deliverables:\n\ndevflow charter (problem statement, non-goals, extension model).\n\nVersioning policy (SemVer + compatibility guarantees for extension API).\n\nContribution and release policy.\n\nAcceptance criteria:\n\nGovernance docs merged.\n\nFirst ADRs approved.","type":"content","url":"/v0-1-0-implementation-execution-plan#a0-governance-and-scope","position":9},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl3":"A1 Core Engine MVP","lvl2":"Workstream A: devflow (Platform)"},"type":"lvl3","url":"/v0-1-0-implementation-execution-plan#a1-core-engine-mvp","position":10},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl3":"A1 Core Engine MVP","lvl2":"Workstream A: devflow (Platform)"},"content":"Deliverables:\n\ndevflow-core DAG/task runtime.\n\nCanonical commands: setup, fmt, fmt-check, lint, build, test, smoke, verify, ci generate.\n\nDeterministic cache contract and container identity resolution.\n\nAcceptance criteria:\n\ndwf verify executes locally in containerized mode.\n\nWorkflow rendering for GitHub Actions works for at least one Rust reference app.","type":"content","url":"/v0-1-0-implementation-execution-plan#a1-core-engine-mvp","position":11},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl3":"A2 Extension System","lvl2":"Workstream A: devflow (Platform)"},"type":"lvl3","url":"/v0-1-0-implementation-execution-plan#a2-extension-system","position":12},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl3":"A2 Extension System","lvl2":"Workstream A: devflow (Platform)"},"content":"Deliverables:\n\ndevflow-ext-rust (first-class).\n\ndevflow-ext-node (baseline).\n\nExtension interface docs, ADRs, and compatibility tests.\n\nStatus: COMPLETE\n\nSame canonical commands resolve correctly for both Rust and Node reference projects.\n\nExtension trait dynamically injects components.\n\nSubprocess extension capability handles arbitrary $PATH binaries (e.g., devflow-ext-python).","type":"content","url":"/v0-1-0-implementation-execution-plan#a2-extension-system","position":13},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl3":"A3 Distribution","lvl2":"Workstream A: devflow (Platform)"},"type":"lvl3","url":"/v0-1-0-implementation-execution-plan#a3-distribution","position":14},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl3":"A3 Distribution","lvl2":"Workstream A: devflow (Platform)"},"content":"Deliverables:\n\nHomebrew formula automation.\n\nBinary signing and release pipeline.\n\nExample projects (rust, node-ts, react, tauri, vscode).\n\nAcceptance criteria:\n\nbrew install path validated.\n\nPublic docs show canonical command mapping by stack.","type":"content","url":"/v0-1-0-implementation-execution-plan#a3-distribution","position":15},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl2":"Workstream B: kroki-rs-nxt (Product)"},"type":"lvl2","url":"/v0-1-0-implementation-execution-plan#workstream-b-kroki-rs-nxt-product","position":16},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl2":"Workstream B: kroki-rs-nxt (Product)"},"content":"","type":"content","url":"/v0-1-0-implementation-execution-plan#workstream-b-kroki-rs-nxt-product","position":17},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl3":"B0 Bootstrap Workspace","lvl2":"Workstream B: kroki-rs-nxt (Product)"},"type":"lvl3","url":"/v0-1-0-implementation-execution-plan#b0-bootstrap-workspace","position":18},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl3":"B0 Bootstrap Workspace","lvl2":"Workstream B: kroki-rs-nxt (Product)"},"content":"Deliverables:\n\nCargo workspace with initial crates:\n\nkroki-core\n\nkroki-contracts\n\nkroki-plugin-api\n\nkroki-plugin-runtime\n\nkroki-adapter-http\n\nkroki-adapter-cli\n\nkroki-observability\n\napps/kroki-server and apps/kroki-cli.\n\ndevflow.toml baseline config.\n\nAcceptance criteria:\n\nWorkspace compiles.\n\nBasic smoke tests pass.","type":"content","url":"/v0-1-0-implementation-execution-plan#b0-bootstrap-workspace","position":19},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl3":"B1 Contract-First Vertical Slice","lvl2":"Workstream B: kroki-rs-nxt (Product)"},"type":"lvl3","url":"/v0-1-0-implementation-execution-plan#b1-contract-first-vertical-slice","position":20},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl3":"B1 Contract-First Vertical Slice","lvl2":"Workstream B: kroki-rs-nxt (Product)"},"content":"Deliverables:\n\nOne end-to-end diagram flow through contracts -> core -> adapter.\n\nContract tests and schema artifact generation.\n\nError envelope standardization.\n\nAcceptance criteria:\n\nGolden tests pass for selected providers.\n\nExternal interface compatibility checks are automated.","type":"content","url":"/v0-1-0-implementation-execution-plan#b1-contract-first-vertical-slice","position":21},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl3":"B2 Provider Migration Slices","lvl2":"Workstream B: kroki-rs-nxt (Product)"},"type":"lvl3","url":"/v0-1-0-implementation-execution-plan#b2-provider-migration-slices","position":22},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl3":"B2 Provider Migration Slices","lvl2":"Workstream B: kroki-rs-nxt (Product)"},"content":"Deliverables:\n\nPriority provider batches migrated with conformance tests.\n\nPlugin/runtime capability policy implemented.\n\nAcceptance criteria:\n\nMigration dashboard shows parity status by provider.\n\nNo regression in baseline latency/error budget.","type":"content","url":"/v0-1-0-implementation-execution-plan#b2-provider-migration-slices","position":23},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl3":"B3 Hardening and Release Readiness","lvl2":"Workstream B: kroki-rs-nxt (Product)"},"type":"lvl3","url":"/v0-1-0-implementation-execution-plan#b3-hardening-and-release-readiness","position":24},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl3":"B3 Hardening and Release Readiness","lvl2":"Workstream B: kroki-rs-nxt (Product)"},"content":"Deliverables:\n\nCI quality gates via devflow.\n\nPerformance tuning and cache observability.\n\nRelease packaging and migration docs.\n\nAcceptance criteria:\n\nRelease candidate checklist passes.\n\nv0.1.0 release approved.","type":"content","url":"/v0-1-0-implementation-execution-plan#b3-hardening-and-release-readiness","position":25},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl2":"Dependency Between Workstreams"},"type":"lvl2","url":"/v0-1-0-implementation-execution-plan#dependency-between-workstreams","position":26},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl2":"Dependency Between Workstreams"},"content":"kroki-rs-nxt B0 can begin with a pinned devflow preview build.\n\nB1+ should use stable devflow command contracts.\n\nAny devflow breaking change requires explicit compatibility notice and migration plan.","type":"content","url":"/v0-1-0-implementation-execution-plan#dependency-between-workstreams","position":27},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl2":"Engineering Governance"},"type":"lvl2","url":"/v0-1-0-implementation-execution-plan#engineering-governance","position":28},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl2":"Engineering Governance"},"content":"Required quality gates per PR:\n\nfmt-check\n\nlint\n\nbuild\n\ntest\n\nsmoke\n\nRequired architecture gates per milestone:\n\nContract conformance.\n\nPlugin capability policy validation.\n\nCI/local parity audit.","type":"content","url":"/v0-1-0-implementation-execution-plan#engineering-governance","position":29},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl2":"Risks and Controls"},"type":"lvl2","url":"/v0-1-0-implementation-execution-plan#risks-and-controls","position":30},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl2":"Risks and Controls"},"content":"Risk: parallel track drift.\n\nControl: weekly architecture sync with explicit decision log.\n\nRisk: tool lock-in before platform maturity.\n\nControl: keep dflow-style compatibility shim until devflow stabilizes.\n\nRisk: over-engineering early layers.\n\nControl: migrate by vertical slices, not by abstract scaffolding alone.","type":"content","url":"/v0-1-0-implementation-execution-plan#risks-and-controls","position":31},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl2":"Suggested Milestone Timeline (Indicative)"},"type":"lvl2","url":"/v0-1-0-implementation-execution-plan#suggested-milestone-timeline-indicative","position":32},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl2":"Suggested Milestone Timeline (Indicative)"},"content":"M1 (2-3 weeks): A0/A1 and B0 complete.\n\nM2 (2-4 weeks): A2 and B1 complete.\n\nM3 (4-6 weeks): B2 provider migration batches.\n\nM4 (2-3 weeks): A3 + B3 hardening and release prep.","type":"content","url":"/v0-1-0-implementation-execution-plan#suggested-milestone-timeline-indicative","position":33},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl2":"Definition of Done for v0.1.0"},"type":"lvl2","url":"/v0-1-0-implementation-execution-plan#definition-of-done-for-v0-1-0","position":34},{"hierarchy":{"lvl1":"v0.1.0 Implementation Execution Plan","lvl2":"Definition of Done for v0.1.0"},"content":"devflow is publicly installable and used by kroki-rs-nxt CI/local workflows.\n\nkroki-rs-nxt delivers agreed parity scope with contract and conformance tests.\n\nMigration and contributor docs are complete and reviewed.","type":"content","url":"/v0-1-0-implementation-execution-plan#definition-of-done-for-v0-1-0","position":35},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record"},"type":"lvl1","url":"/v0-1-0-platform-migration-decision","position":0},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record"},"content":"","type":"content","url":"/v0-1-0-platform-migration-decision","position":1},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Decision Statement"},"type":"lvl2","url":"/v0-1-0-platform-migration-decision#decision-statement","position":2},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Decision Statement"},"content":"For v0.1.0 and beyond:\n\nBuild devflow as an independent open-source repository and release it as a standalone CLI (devflow, alias dwf).\n\nCreate kroki-rs-nxt as a new repository for next-generation architecture.\n\nKeep current kroki-rs as a stable/maintenance line during migration.\n\nStart kroki-rs-nxt as a single workspace monorepo (not many repos at first), then split only when ownership and release velocity justify it.","type":"content","url":"/v0-1-0-platform-migration-decision#decision-statement","position":3},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Context"},"type":"lvl2","url":"/v0-1-0-platform-migration-decision#context","position":4},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Context"},"content":"Two major tracks are in flight:\n\nTrack A: generic workflow platform (devflow) reusable across stacks.\n\nTrack B: major architecture refactor for Kroki (multi-surface model).\n\nTrying to do both as in-place refactors in the same repository creates high coupling risk and weakens governance clarity for open-source contributors.","type":"content","url":"/v0-1-0-platform-migration-decision#context","position":5},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Options Evaluated"},"type":"lvl2","url":"/v0-1-0-platform-migration-decision#options-evaluated","position":6},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Options Evaluated"},"content":"","type":"content","url":"/v0-1-0-platform-migration-decision#options-evaluated","position":7},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl3":"Option A: New kroki-rs-nxt repository + new devflow repository","lvl2":"Options Evaluated"},"type":"lvl3","url":"/v0-1-0-platform-migration-decision#option-a-new-kroki-rs-nxt-repository-new-devflow-repository","position":8},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl3":"Option A: New kroki-rs-nxt repository + new devflow repository","lvl2":"Options Evaluated"},"content":"Pros:\n\nClean architectural runway; no legacy constraints in the new design.\n\nStronger decision hygiene and contributor clarity.\n\nEasier to enforce canonical workflow graph and plugin boundaries from day one.\n\nCons:\n\nDual-repo overhead (issues, releases, docs, CI).\n\nMigration complexity and temporary duplication of effort.\n\nRequires clear compatibility and deprecation policy.","type":"content","url":"/v0-1-0-platform-migration-decision#option-a-new-kroki-rs-nxt-repository-new-devflow-repository","position":9},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl3":"Option B: In-place refactor of current kroki-rs while creating devflow","lvl2":"Options Evaluated"},"type":"lvl3","url":"/v0-1-0-platform-migration-decision#option-b-in-place-refactor-of-current-kroki-rs-while-creating-devflow","position":10},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl3":"Option B: In-place refactor of current kroki-rs while creating devflow","lvl2":"Options Evaluated"},"content":"Pros:\n\nSingle repo continuity.\n\nLower initial operational overhead.\n\nCons:\n\nHigher risk of “hybrid limbo” architecture.\n\nSlower deep refactor due to compatibility pressure.\n\nHarder to keep contributor mental model clear.","type":"content","url":"/v0-1-0-platform-migration-decision#option-b-in-place-refactor-of-current-kroki-rs-while-creating-devflow","position":11},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Rationale for Selected Direction"},"type":"lvl2","url":"/v0-1-0-platform-migration-decision#rationale-for-selected-direction","position":12},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Rationale for Selected Direction"},"content":"We choose Option A with a strict execution guard:\n\ndevflow and kroki-rs-nxt are separate from day one.\n\nkroki-rs-nxt stays monorepo workspace initially.\n\nMulti-repo fragmentation is postponed until evidence shows it is needed.\n\nThis gives deterministic architecture evolution with less long-term maintenance debt.","type":"content","url":"/v0-1-0-platform-migration-decision#rationale-for-selected-direction","position":13},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Ruthless Review Outcomes from Brainstorm Docs"},"type":"lvl2","url":"/v0-1-0-platform-migration-decision#ruthless-review-outcomes-from-brainstorm-docs","position":14},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Ruthless Review Outcomes from Brainstorm Docs"},"content":"Key concerns identified in brainstorm artifacts:\n\nMulti-repo-first design is over-ambitious without concrete release/versioning governance.\n\nLayer count is high; without strict phase gates it can become abstraction tax.\n\nMulti-format serialization should be staged, not implemented all at once.\n\nPlugin/WASM model needs explicit ABI/capability contracts before broad adoption.\n\nTherefore:\n\nStart with one canonical external contract format and add others only when measured need exists.\n\nIntroduce plugin runtime as a bounded subsystem with explicit compatibility policy.\n\nTreat architecture documents as directional until backed by executable conformance checks.","type":"content","url":"/v0-1-0-platform-migration-decision#ruthless-review-outcomes-from-brainstorm-docs","position":15},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Target Repository Structures"},"type":"lvl2","url":"/v0-1-0-platform-migration-decision#target-repository-structures","position":16},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Target Repository Structures"},"content":"","type":"content","url":"/v0-1-0-platform-migration-decision#target-repository-structures","position":17},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl3":"devflow","lvl2":"Target Repository Structures"},"type":"lvl3","url":"/v0-1-0-platform-migration-decision#devflow","position":18},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl3":"devflow","lvl2":"Target Repository Structures"},"content":"devflow/\n  Cargo.toml\n  crates/\n    devflow-core/\n    devflow-cli/\n    devflow-gh/\n    devflow-ext-rust/\n    devflow-ext-node/\n    devflow-ext-react/\n    devflow-ext-lit/\n    devflow-ext-vscode/\n    devflow-ext-tauri/\n  examples/\n    rust-lib/\n    node-ts/\n    react/\n    tauri/\n    vscode-extension/\n  docs/","type":"content","url":"/v0-1-0-platform-migration-decision#devflow","position":19},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl3":"kroki-rs-nxt","lvl2":"Target Repository Structures"},"type":"lvl3","url":"/v0-1-0-platform-migration-decision#kroki-rs-nxt","position":20},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl3":"kroki-rs-nxt","lvl2":"Target Repository Structures"},"content":"kroki-rs-nxt/\n  Cargo.toml\n  crates/\n    kroki-core/\n    kroki-contracts/\n    kroki-plugin-api/\n    kroki-plugin-runtime/\n    kroki-adapter-http/\n    kroki-adapter-cli/\n    kroki-observability/\n  apps/\n    kroki-server/\n    kroki-cli/\n  plugins/\n  tests/\n    contract/\n    integration/\n    conformance/\n  schemas/\n  devflow.toml","type":"content","url":"/v0-1-0-platform-migration-decision#kroki-rs-nxt","position":21},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Rollout Plan with Phase Gates"},"type":"lvl2","url":"/v0-1-0-platform-migration-decision#rollout-plan-with-phase-gates","position":22},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Rollout Plan with Phase Gates"},"content":"","type":"content","url":"/v0-1-0-platform-migration-decision#rollout-plan-with-phase-gates","position":23},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl3":"Phase 0: Governance and Contracts","lvl2":"Rollout Plan with Phase Gates"},"type":"lvl3","url":"/v0-1-0-platform-migration-decision#phase-0-governance-and-contracts","position":24},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl3":"Phase 0: Governance and Contracts","lvl2":"Rollout Plan with Phase Gates"},"content":"Define compatibility/deprecation policy.\n\nDefine versioning strategy for devflow and kroki-rs-nxt.\n\nDefine required quality gates and ownership model.\n\nExit criteria:\n\nPublished governance docs and contribution model.\n\nBaseline ADRs approved.","type":"content","url":"/v0-1-0-platform-migration-decision#phase-0-governance-and-contracts","position":25},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl3":"Phase 1: devflow MVP","lvl2":"Rollout Plan with Phase Gates"},"type":"lvl3","url":"/v0-1-0-platform-migration-decision#phase-1-devflow-mvp","position":26},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl3":"Phase 1: devflow MVP","lvl2":"Rollout Plan with Phase Gates"},"content":"Implement canonical command graph (setup, fmt, lint, build, test, verify, ci generate).\n\nImplement Rust extension first, along with Node parity.\n\nGenerate reproducible CI workflow and local container execution.\n\nImplement Subprocess Extensions for multi-language future-proofing.\n\nStatus: COMPLETE\n\nExit criteria met:\n\ndevflow runs on at least one Rust reference project (Validated via examples/rust-lib).\n\nExecution architecture supports completely uncoupled external binaries via standard JSON/stdio (Phase 2 constraint validated via examples/python-ext).\n\nNode, Typescript, and Hybrid stacks evaluate correctly (Validated via examples/node-ts, examples/react, examples/tauri, and examples/vscode-extension).","type":"content","url":"/v0-1-0-platform-migration-decision#phase-1-devflow-mvp","position":27},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl3":"Phase 2: kroki-rs-nxt Bootstrap","lvl2":"Rollout Plan with Phase Gates"},"type":"lvl3","url":"/v0-1-0-platform-migration-decision#phase-2-kroki-rs-nxt-bootstrap","position":28},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl3":"Phase 2: kroki-rs-nxt Bootstrap","lvl2":"Rollout Plan with Phase Gates"},"content":"Scaffold workspace structure.\n\nPort core domain and contracts first.\n\nIntegrate devflow in CI and local workflow from start.\n\nExit criteria:\n\nCore + CLI + HTTP adapter compile and pass baseline tests.","type":"content","url":"/v0-1-0-platform-migration-decision#phase-2-kroki-rs-nxt-bootstrap","position":29},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl3":"Phase 3: Feature Migration by Capability Slice","lvl2":"Rollout Plan with Phase Gates"},"type":"lvl3","url":"/v0-1-0-platform-migration-decision#phase-3-feature-migration-by-capability-slice","position":30},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl3":"Phase 3: Feature Migration by Capability Slice","lvl2":"Rollout Plan with Phase Gates"},"content":"Migrate providers/plugins in prioritized batches.\n\nAdd contract/conformance tests per slice.\n\nExit criteria:\n\nFeature parity target reached for v0.1.0 scope.","type":"content","url":"/v0-1-0-platform-migration-decision#phase-3-feature-migration-by-capability-slice","position":31},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl3":"Phase 4: Stabilization and Release","lvl2":"Rollout Plan with Phase Gates"},"type":"lvl3","url":"/v0-1-0-platform-migration-decision#phase-4-stabilization-and-release","position":32},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl3":"Phase 4: Stabilization and Release","lvl2":"Rollout Plan with Phase Gates"},"content":"Performance/correctness hardening.\n\nPackaging and release automation via devflow.\n\nPublish migration guide from kroki-rs to kroki-rs-nxt.\n\nExit criteria:\n\nv0.1.0 RC passes all quality gates and release checklist.","type":"content","url":"/v0-1-0-platform-migration-decision#phase-4-stabilization-and-release","position":33},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Risks and Mitigations"},"type":"lvl2","url":"/v0-1-0-platform-migration-decision#risks-and-mitigations","position":34},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Risks and Mitigations"},"content":"Risk: over-abstraction in early architecture.\n\nMitigation: enforce phase gates and measurable adoption criteria.\n\nRisk: contributor confusion between repos.\n\nMitigation: publish explicit repo purpose and migration matrix.\n\nRisk: tool/project coupling (devflow too Kroki-specific).\n\nMitigation: extension API and example projects across stacks.\n\nRisk: release burden across two active lines.\n\nMitigation: designate kroki-rs as maintenance-only during transition.","type":"content","url":"/v0-1-0-platform-migration-decision#risks-and-mitigations","position":35},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Pros/Cons of the Chosen Path"},"type":"lvl2","url":"/v0-1-0-platform-migration-decision#pros-cons-of-the-chosen-path","position":36},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Pros/Cons of the Chosen Path"},"content":"Pros:\n\nHigh architectural clarity and long-term maintainability.\n\nStronger reuse potential through devflow.\n\nBetter open-source governance through explicit boundaries.\n\nCons:\n\nHigher short-term setup and coordination cost.\n\nRequires disciplined phase governance and clear communication.","type":"content","url":"/v0-1-0-platform-migration-decision#pros-cons-of-the-chosen-path","position":37},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Reference Learnings"},"type":"lvl2","url":"/v0-1-0-platform-migration-decision#reference-learnings","position":38},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Reference Learnings"},"content":"The following ecosystems inform this decision:\n\nRust workspace model and staged modularization:\n\nhttps://​doc​.rust​-lang​.org​/book​/ch14​-03​-cargo​-workspaces​.html\n\nTauri ecosystem (Rust + frontend integration, monorepo evolution):\n\nhttps://​github​.com​/tauri​-apps​/tauri\n\nhttps://​v2​.tauri​.app/\n\nTerraform plugin protocol/versioning discipline:\n\nhttps://​developer​.hashicorp​.com​/terraform​/plugin​/how​-terraform​-works​#provider​-plugins\n\nNx plugin/extensibility model for reusable developer workflows:\n\nhttps://​nx​.dev​/concepts​/plugins​/introduction\n\nGitHub reusable workflow patterns:\n\nhttps://​docs​.github​.com​/actions​/using​-workflows​/reusing​-workflows\n\ncargo-nextest as scalable Rust CI test runner:\n\nhttps://​nexte​.st​/docs/","type":"content","url":"/v0-1-0-platform-migration-decision#reference-learnings","position":39},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Review Cadence"},"type":"lvl2","url":"/v0-1-0-platform-migration-decision#review-cadence","position":40},{"hierarchy":{"lvl1":"v0.1.0 Platform & Migration Decision Record","lvl2":"Review Cadence"},"content":"Revisit this decision at the end of each phase.\n\nIf phase exit criteria fail twice consecutively, open a decision review issue and adjust scope/sequence before continuing.","type":"content","url":"/v0-1-0-platform-migration-decision#review-cadence","position":41},{"hierarchy":{"lvl1":"References"},"type":"lvl1","url":"/references","position":0},{"hierarchy":{"lvl1":"References"},"content":"Rust workspace model: \n\nhttps://​doc​.rust​-lang​.org​/book​/ch14​-03​-cargo​-workspaces​.html\n\nGitHub Actions docs: \n\nhttps://​docs​.github​.com​/actions\n\nMyST docs: \n\nhttps://mystmd.org","type":"content","url":"/references","position":1},{"hierarchy":{"lvl1":"Developer Guide"},"type":"lvl1","url":"/developer-index","position":0},{"hierarchy":{"lvl1":"Developer Guide"},"content":"Use this guide to understand internals, contribute, and extend Devflow.\n\n01 Getting Started\n\n02 Design\n\n03 Development\n\n04 Infrastructure\n\n05 Operations\n\n06 Roadmap\n\n07 Resources","type":"content","url":"/developer-index","position":1},{"hierarchy":{"lvl1":"Glossary"},"type":"lvl1","url":"/glossary","position":0},{"hierarchy":{"lvl1":"Glossary"},"content":"","type":"content","url":"/glossary","position":1},{"hierarchy":{"lvl1":"Glossary","lvl2":"Canonical Command"},"type":"lvl2","url":"/glossary#canonical-command","position":2},{"hierarchy":{"lvl1":"Glossary","lvl2":"Canonical Command"},"content":"A stable top-level command in devflow that maps to stack-specific execution.","type":"content","url":"/glossary#canonical-command","position":3},{"hierarchy":{"lvl1":"Glossary","lvl2":"Extension"},"type":"lvl2","url":"/glossary#extension","position":4},{"hierarchy":{"lvl1":"Glossary","lvl2":"Extension"},"content":"A stack adapter module (devflow-ext-*) that resolves canonical commands for a toolchain.","type":"content","url":"/glossary#extension","position":5},{"hierarchy":{"lvl1":"Glossary","lvl2":"Fingerprint"},"type":"lvl2","url":"/glossary#fingerprint","position":6},{"hierarchy":{"lvl1":"Glossary","lvl2":"Fingerprint"},"content":"A deterministic hash input set used to identify container/runtime build identity.","type":"content","url":"/glossary#fingerprint","position":7},{"hierarchy":{"lvl1":"Glossary","lvl2":"Parity"},"type":"lvl2","url":"/glossary#parity","position":8},{"hierarchy":{"lvl1":"Glossary","lvl2":"Parity"},"content":"Equivalent behavior and verification logic across local and CI environments.","type":"content","url":"/glossary#parity","position":9},{"hierarchy":{"lvl1":"Devflow - Deterministic Developer Workflows"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Devflow - Deterministic Developer Workflows"},"content":"Deterministic Workflows","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Devflow - Deterministic Developer Workflows","lvl2":"One Command Surface"},"type":"lvl2","url":"/#one-command-surface","position":2},{"hierarchy":{"lvl1":"Devflow - Deterministic Developer Workflows","lvl2":"One Command Surface"},"content":"","type":"content","url":"/#one-command-surface","position":3},{"hierarchy":{"lvl1":"Devflow - Deterministic Developer Workflows","lvl2":"Local and CI Parity"},"type":"lvl2","url":"/#local-and-ci-parity","position":4},{"hierarchy":{"lvl1":"Devflow - Deterministic Developer Workflows","lvl2":"Local and CI Parity"},"content":"Devflow provides stable commands and profile-driven orchestration for building, testing, and validating software across stacks.\n\nGet Started\n\n","type":"content","url":"/#local-and-ci-parity","position":5},{"hierarchy":{"lvl1":"Devflow - Deterministic Developer Workflows","lvl3":"What Devflow Solves","lvl2":"Local and CI Parity"},"type":"lvl3","url":"/#what-devflow-solves","position":6},{"hierarchy":{"lvl1":"Devflow - Deterministic Developer Workflows","lvl3":"What Devflow Solves","lvl2":"Local and CI Parity"},"content":"Consistent command contract (setup, fmt, lint, build, test, check, release, ci).\n\nSelector-based precision (test:unit, check:pr, ci:generate).\n\nConfig-first policy (targets.*) with deterministic CI generation.","type":"content","url":"/#what-devflow-solves","position":7},{"hierarchy":{"lvl1":"Devflow - Deterministic Developer Workflows","lvl3":"Who It Is For","lvl2":"Local and CI Parity"},"type":"lvl3","url":"/#who-it-is-for","position":8},{"hierarchy":{"lvl1":"Devflow - Deterministic Developer Workflows","lvl3":"Who It Is For","lvl2":"Local and CI Parity"},"content":"Teams maintaining one or many repositories with inconsistent local/CI workflows.\n\nEngineers who want predictable quality gates without custom per-repo script sprawl.\n\nContributors extending workflow behavior through explicit extension capabilities.","type":"content","url":"/#who-it-is-for","position":9},{"hierarchy":{"lvl1":"Devflow - Deterministic Developer Workflows","lvl3":"Mission and Objectives","lvl2":"Local and CI Parity"},"type":"lvl3","url":"/#mission-and-objectives","position":10},{"hierarchy":{"lvl1":"Devflow - Deterministic Developer Workflows","lvl3":"Mission and Objectives","lvl2":"Local and CI Parity"},"content":"Mission: make software delivery workflows consistent, repeatable, and easy to reason about.\n\nObjectives:\n\ndefine one canonical command surface across stacks\n\nkeep local and CI behavior aligned from the same config contract\n\nmake workflow policy explicit and versionable (devflow.toml)\n\nenable safe extensibility through capability-checked extensions","type":"content","url":"/#mission-and-objectives","position":11},{"hierarchy":{"lvl1":"Devflow - Deterministic Developer Workflows","lvl3":"Documentation Paths","lvl2":"Local and CI Parity"},"type":"lvl3","url":"/#documentation-paths","position":12},{"hierarchy":{"lvl1":"Devflow - Deterministic Developer Workflows","lvl3":"Documentation Paths","lvl2":"Local and CI Parity"},"content":"User Guide: install, configure, and run Devflow.\n\nDeveloper Guide: architecture, extension model, and contribution workflow.","type":"content","url":"/#documentation-paths","position":13},{"hierarchy":{"lvl1":"Reference"},"type":"lvl1","url":"/reference","position":0},{"hierarchy":{"lvl1":"Reference"},"content":"Glossary","type":"content","url":"/reference","position":1},{"hierarchy":{"lvl1":"CI Workflows"},"type":"lvl1","url":"/ci-workflows","position":0},{"hierarchy":{"lvl1":"CI Workflows"},"content":"","type":"content","url":"/ci-workflows","position":1},{"hierarchy":{"lvl1":"CI Workflows","lvl2":"Goal"},"type":"lvl2","url":"/ci-workflows#goal","position":2},{"hierarchy":{"lvl1":"CI Workflows","lvl2":"Goal"},"content":"Keep CI workflow files synchronized with devflow.toml policy and command contracts.","type":"content","url":"/ci-workflows#goal","position":3},{"hierarchy":{"lvl1":"CI Workflows","lvl2":"ci:generate"},"type":"lvl2","url":"/ci-workflows#ci-generate","position":4},{"hierarchy":{"lvl1":"CI Workflows","lvl2":"ci:generate"},"content":"dwf ci:generate\n\nWhat it does:\n\ngenerates workflow YAML based on current config (targets.pr)\n\nwrites to .github/workflows/ci.yml by default\n\noverwrites existing file content with the latest generated contract\n\nIf you modify config locally and run ci:generate again, it re-syncs the workflow file.\n\nCustom output path:dwf --ci-output .github/workflows/devflow-ci.yml ci:generate\n\nPreview without writing:dwf --stdout ci:generate","type":"content","url":"/ci-workflows#ci-generate","position":5},{"hierarchy":{"lvl1":"CI Workflows","lvl2":"ci:check"},"type":"lvl2","url":"/ci-workflows#ci-check","position":6},{"hierarchy":{"lvl1":"CI Workflows","lvl2":"ci:check"},"content":"dwf ci:check\n\nWhat it checks:\n\nrequired workflow topology (prep, build, profile-derived check_* jobs)\n\ncommand coverage for targets.pr\n\ndrift between on-disk workflow and expected generated output\n\nIf drift is detected, run:dwf ci:generate","type":"content","url":"/ci-workflows#ci-check","position":7},{"hierarchy":{"lvl1":"CI Workflows","lvl2":"ci:plan"},"type":"lvl2","url":"/ci-workflows#ci-plan","position":8},{"hierarchy":{"lvl1":"CI Workflows","lvl2":"ci:plan"},"content":"dwf ci:plan\n\nShows configured target profile names (pr, main, release, custom profiles).","type":"content","url":"/ci-workflows#ci-plan","position":9},{"hierarchy":{"lvl1":"Commands"},"type":"lvl1","url":"/commands","position":0},{"hierarchy":{"lvl1":"Commands"},"content":"This page explains what each command family is for before listing concrete selectors.","type":"content","url":"/commands","position":1},{"hierarchy":{"lvl1":"Commands","lvl2":"How to Read Command Names"},"type":"lvl2","url":"/commands#how-to-read-command-names","position":2},{"hierarchy":{"lvl1":"Commands","lvl2":"How to Read Command Names"},"content":"Primary command: high-level intent (test, check, ci)\n\nSelector: specific behavior (test:unit, check:pr, ci:generate)\n\nGeneral form:dwf <primary>:<selector>","type":"content","url":"/commands#how-to-read-command-names","position":3},{"hierarchy":{"lvl1":"Commands","lvl2":"Primary Commands"},"type":"lvl2","url":"/commands#primary-commands","position":4},{"hierarchy":{"lvl1":"Commands","lvl2":"Primary Commands"},"content":"Command\n\nPurpose\n\nTypical Usage\n\nMutates Files?\n\ninit\n\nbootstrap config and starter CI workflow\n\ninit, init rust, init kotlin\n\nyes\n\nsetup\n\nprepare dependencies and environment checks\n\nsetup:doctor, setup:deps\n\nsometimes\n\nfmt\n\nformatting checks/fixes\n\nfmt:check, fmt:fix\n\nfmt:fix yes\n\nlint\n\nstatic/policy analysis\n\nlint:static\n\nno\n\nbuild\n\ncompile/package prep builds\n\nbuild:debug, build:release\n\nbuild artifacts only\n\ntest\n\nexecute test scopes\n\ntest:unit, test:integration, test:smoke\n\nno\n\npackage\n\nprepare distributable outputs\n\npackage:artifact\n\nartifacts only\n\ncheck\n\nrun a configured quality profile\n\ncheck:pr, check:main\n\ndepends on profile\n\nrelease\n\nrelease-oriented tasks\n\nrelease:candidate\n\nartifacts/metadata\n\nci\n\nCI workflow generation and validation\n\nci:generate, ci:check, ci:plan\n\nci:generate yes","type":"content","url":"/commands#primary-commands","position":5},{"hierarchy":{"lvl1":"Commands","lvl2":"Common Selectors"},"type":"lvl2","url":"/commands#common-selectors","position":6},{"hierarchy":{"lvl1":"Commands","lvl2":"Common Selectors"},"content":"","type":"content","url":"/commands#common-selectors","position":7},{"hierarchy":{"lvl1":"Commands","lvl3":"Initialization","lvl2":"Common Selectors"},"type":"lvl3","url":"/commands#initialization","position":8},{"hierarchy":{"lvl1":"Commands","lvl3":"Initialization","lvl2":"Common Selectors"},"content":"init: auto-detect template from repository files\n\ninit:rust or init rust: rust-oriented config and CI starter\n\ninit:node or init node: node-oriented config and CI starter\n\ninit:tsc or init tsc: typescript-oriented config and CI starter\n\ninit:kotlin or init kotlin: custom stack config for Make/Just-backed Kotlin workflows","type":"content","url":"/commands#initialization","position":9},{"hierarchy":{"lvl1":"Commands","lvl3":"Quality Profiles","lvl2":"Common Selectors"},"type":"lvl3","url":"/commands#quality-profiles","position":10},{"hierarchy":{"lvl1":"Commands","lvl3":"Quality Profiles","lvl2":"Common Selectors"},"content":"check:pr: runs [targets].pr\n\ncheck:main: runs [targets].main\n\ncheck:<custom>: runs any custom profile key defined under [targets]","type":"content","url":"/commands#quality-profiles","position":11},{"hierarchy":{"lvl1":"Commands","lvl3":"CI Lifecycle","lvl2":"Common Selectors"},"type":"lvl3","url":"/commands#ci-lifecycle","position":12},{"hierarchy":{"lvl1":"Commands","lvl3":"CI Lifecycle","lvl2":"Common Selectors"},"content":"ci:generate: generate .github/workflows/ci.yml from config\n\nci:check: validate on-disk workflow topology and detect drift\n\nci:plan: list configured profile keys used by CI policy","type":"content","url":"/commands#ci-lifecycle","position":13},{"hierarchy":{"lvl1":"Commands","lvl3":"fmt:check vs fmt:fix","lvl2":"Common Selectors"},"type":"lvl3","url":"/commands#fmt-check-vs-fmt-fix","position":14},{"hierarchy":{"lvl1":"Commands","lvl3":"fmt:check vs fmt:fix","lvl2":"Common Selectors"},"content":"Command\n\nResponsibility\n\nTypical Use\n\nfmt:check\n\nverify formatting compliance only\n\nCI and pre-merge checks\n\nfmt:fix\n\napply formatter changes to files\n\nlocal editing loop","type":"content","url":"/commands#fmt-check-vs-fmt-fix","position":15},{"hierarchy":{"lvl1":"Commands","lvl3":"Typical Local Loop","lvl2":"Common Selectors"},"type":"lvl3","url":"/commands#typical-local-loop","position":16},{"hierarchy":{"lvl1":"Commands","lvl3":"Typical Local Loop","lvl2":"Common Selectors"},"content":"dwf fmt:check\ndwf lint:static\ndwf test:unit\ndwf check:pr","type":"content","url":"/commands#typical-local-loop","position":17},{"hierarchy":{"lvl1":"Configuration"},"type":"lvl1","url":"/configuration","position":0},{"hierarchy":{"lvl1":"Configuration"},"content":"devflow.toml is the source of truth for workflow behavior.","type":"content","url":"/configuration","position":1},{"hierarchy":{"lvl1":"Configuration","lvl2":"Full Example"},"type":"lvl2","url":"/configuration#full-example","position":2},{"hierarchy":{"lvl1":"Configuration","lvl2":"Full Example"},"content":"[project]\nname = \"my-project\"\nstack = [\"rust\", \"node\"]\n\n[runtime]\n# Runtime execution profile for command execution\n# Allowed values: container | host | auto\nprofile = \"auto\"\n\n[targets]\n# Profile names are user-defined map keys.\n# Common names: pr, main, release, staging, hotfix\npr = [\"fmt:check\", \"lint:static\", \"build:debug\", \"test:unit\", \"test:integration\"]\nmain = [\"fmt:check\", \"lint:static\", \"build:release\", \"test:unit\", \"test:integration\", \"test:smoke\"]\nstaging = [\"fmt:check\", \"lint:static\", \"build:release\", \"test:unit\", \"test:integration\", \"package:artifact\"]\n\n[extensions.rust]\nsource = \"builtin\"\nrequired = true\n# Optional explicit capabilities. If omitted for builtin extension,\n# default capabilities are loaded from the extension crate.\n# capabilities = [\"fmt:check\", \"lint:static\", \"test:unit\"]\n\n[extensions.node]\nsource = \"builtin\"\nrequired = false\n\n# Example path extension\n[extensions.custom]\nsource = \"path\"\npath = \"./tools/devflow-ext-custom\"\nrequired = false\ncapabilities = [\"lint:policy\"]","type":"content","url":"/configuration#full-example","position":3},{"hierarchy":{"lvl1":"Configuration","lvl2":"Section Details"},"type":"lvl2","url":"/configuration#section-details","position":4},{"hierarchy":{"lvl1":"Configuration","lvl2":"Section Details"},"content":"","type":"content","url":"/configuration#section-details","position":5},{"hierarchy":{"lvl1":"Configuration","lvl3":"[project]","lvl2":"Section Details"},"type":"lvl3","url":"/configuration#id-project","position":6},{"hierarchy":{"lvl1":"Configuration","lvl3":"[project]","lvl2":"Section Details"},"content":"name: logical project name used by generated outputs.\n\nstack: list of enabled stacks.\n\nAllowed values today: rust, node, custom\n\ncustom delegates canonical commands to justfile or Makefile targets.","type":"content","url":"/configuration#id-project","position":7},{"hierarchy":{"lvl1":"Configuration","lvl3":"[runtime]","lvl2":"Section Details"},"type":"lvl3","url":"/configuration#id-runtime","position":8},{"hierarchy":{"lvl1":"Configuration","lvl3":"[runtime]","lvl2":"Section Details"},"content":"profile: runtime execution profile.\n\ncontainer: force container-oriented execution mode\n\nhost: run directly on host toolchain\n\nauto: choose best available mode (default)","type":"content","url":"/configuration#id-runtime","position":9},{"hierarchy":{"lvl1":"Configuration","lvl3":"[targets]","lvl2":"Section Details"},"type":"lvl3","url":"/configuration#id-targets","position":10},{"hierarchy":{"lvl1":"Configuration","lvl3":"[targets]","lvl2":"Section Details"},"content":"dynamic profile map used by check:<profile> and CI generation.\n\neach profile value is an ordered list of canonical command selectors.\n\nexamples: check:pr, check:main, check:staging","type":"content","url":"/configuration#id-targets","position":11},{"hierarchy":{"lvl1":"Configuration","lvl3":"[extensions.<name>]","lvl2":"Section Details"},"type":"lvl3","url":"/configuration#id-extensions-name","position":12},{"hierarchy":{"lvl1":"Configuration","lvl3":"[extensions.<name>]","lvl2":"Section Details"},"content":"source: builtin or path\n\npath: required when source = \"path\"\n\nrequired: if true, load/validation failure is fatal\n\ncapabilities: optional explicit capability list","type":"content","url":"/configuration#id-extensions-name","position":13},{"hierarchy":{"lvl1":"Configuration","lvl2":"custom Stack Command Mapping"},"type":"lvl2","url":"/configuration#custom-stack-command-mapping","position":14},{"hierarchy":{"lvl1":"Configuration","lvl2":"custom Stack Command Mapping"},"content":"When stack = [\"custom\"], Devflow maps selectors to just/make targets by replacing : with -.\n\nExamples:\n\nfmt:check -> fmt-check\n\nlint:static -> lint-static\n\nbuild:debug -> build-debug\n\ntest:unit -> test-unit\n\nExecution order:\n\nuse just <target> when justfile exists and just is installed\n\notherwise use make <target> when Makefile exists","type":"content","url":"/configuration#custom-stack-command-mapping","position":15},{"hierarchy":{"lvl1":"Configuration","lvl2":"Validation Rules"},"type":"lvl2","url":"/configuration#validation-rules","position":16},{"hierarchy":{"lvl1":"Configuration","lvl2":"Validation Rules"},"content":"unknown config keys fail\n\ninvalid command syntax in target profiles fails\n\nunsupported selectors relative to loaded extensions fail","type":"content","url":"/configuration#validation-rules","position":17},{"hierarchy":{"lvl1":"Using Custom Extensions"},"type":"lvl1","url":"/custom-extensions","position":0},{"hierarchy":{"lvl1":"Using Custom Extensions"},"content":"Devflow separates its core orchestration engine from the logic used to build, test, and package your software. The logic is handled by Extensions—specialized programs that connect to Devflow.\n\nWhile Devflow comes with official extensions for languages like Rust or Node.js, you may need to use Custom Extensions provided by your organization or the open-source community. Let’s look at how to use and manage extensions.","type":"content","url":"/custom-extensions","position":1},{"hierarchy":{"lvl1":"Using Custom Extensions","lvl2":"How Extensions Work"},"type":"lvl2","url":"/custom-extensions#how-extensions-work","position":2},{"hierarchy":{"lvl1":"Using Custom Extensions","lvl2":"How Extensions Work"},"content":"When you type devflow test, Devflow doesn’t actually know how to run tests for your project. Instead, it:\n\nSearches your system for installed extensions.\n\nIdentifies which extension claimed support for the test capability.\n\nDelegates the heavy lifting to that extension, which then figures out whether to call cargo test, npm run test, pytest, etc.","type":"content","url":"/custom-extensions#how-extensions-work","position":3},{"hierarchy":{"lvl1":"Using Custom Extensions","lvl2":"Finding and Installing Extensions"},"type":"lvl2","url":"/custom-extensions#finding-and-installing-extensions","position":4},{"hierarchy":{"lvl1":"Using Custom Extensions","lvl2":"Finding and Installing Extensions"},"content":"Extensions are simply executable binaries or scripts in your $PATH that start with the devflow-ext- prefix.\nTo install an extension:\n\nDownload the Binary: Drop the devflow-ext-xyz binary into a folder that falls into your system $PATH (e.g., /usr/local/bin or your ~/bin path).\n\nVerify it’s Executable: Make sure your operating system is permitted to run it (chmod +x devflow-ext-xyz on Linux/macOS).\n\nOnce in your $PATH, Devflow automatically discovers it the next time you run a command.","type":"content","url":"/custom-extensions#finding-and-installing-extensions","position":5},{"hierarchy":{"lvl1":"Using Custom Extensions","lvl2":"Troubleshooting Extensions"},"type":"lvl2","url":"/custom-extensions#troubleshooting-extensions","position":6},{"hierarchy":{"lvl1":"Using Custom Extensions","lvl2":"Troubleshooting Extensions"},"content":"If a command fails because an extension isn’t running as expected, you can manually isolate the problem without running Devflow.\n\nCheck if Devflow sees the extension:\nExecute the extension directly with the --discover flag to ensure it’s responding with capabilities.# Make sure the extension is in your PATH.\ndevflow-ext-myplugin --discover\n\nExpected output: [\"test\", \"build\", \"fmt\"]\n\nDiagnose capability gaps:\nIf you get an error saying Devflow does not expose a capability like test:integration, you can check the JSON output of the discover command above to confirm whether the author missed it.\n\nCheck execution actions:\nYou can mock what Devflow does by streaming a JSON payload to the extension:echo '{\"primary\": \"test\"}' | devflow-ext-myplugin --build-action\n\nYou should see a printed JSON object showing what program the extension is trying to invoke (e.g. {\"program\": \"pytest\", \"args\": [\"tests/\"]}).","type":"content","url":"/custom-extensions#troubleshooting-extensions","position":7},{"hierarchy":{"lvl1":"Using Custom Extensions","lvl2":"Developing Your Own"},"type":"lvl2","url":"/custom-extensions#developing-your-own","position":8},{"hierarchy":{"lvl1":"Using Custom Extensions","lvl2":"Developing Your Own"},"content":"Devflow extensions can be built in any language—Go, Python, Bash, Rust, etc.—because they communicate via simple standard JSON payload I/O. For detailed tutorials on creating your own custom extensions, please check our \n\nDeveloper Guide.","type":"content","url":"/custom-extensions#developing-your-own","position":9},{"hierarchy":{"lvl1":"Core Principles and Features"},"type":"lvl1","url":"/features","position":0},{"hierarchy":{"lvl1":"Core Principles and Features"},"content":"","type":"content","url":"/features","position":1},{"hierarchy":{"lvl1":"Core Principles and Features","lvl2":"Principles"},"type":"lvl2","url":"/features#principles","position":2},{"hierarchy":{"lvl1":"Core Principles and Features","lvl2":"Principles"},"content":"Canonical command contract: stable top-level verbs (setup, fmt, lint, build, test, check, release, ci).\n\nSelector precision: scoped behavior with primary:selector (test:unit, check:pr).\n\nConfig as policy: target profiles live in devflow.toml, not duplicated shell/YAML snippets.\n\nReproducibility first: workflow intent is explicit and machine-validated.\n\nComplement, not replacement: Devflow standardizes command intent and orchestration; your existing Makefile/justfile can still own stack-specific internals.","type":"content","url":"/features#principles","position":3},{"hierarchy":{"lvl1":"Core Principles and Features","lvl2":"Feature Summary"},"type":"lvl2","url":"/features#feature-summary","position":4},{"hierarchy":{"lvl1":"Core Principles and Features","lvl2":"Feature Summary"},"content":"dynamic target profiles (pr, main, staging, etc.)\n\nstrict config validation (unknown keys fail)\n\nextension capability checks before execution\n\nCI workflow generation (ci:generate) and topology validation (ci:check)\n\nstack-aware command execution (currently Rust and Node)\n\ncustom stack delegation to just/make targets for new ecosystems (for example Kotlin)","type":"content","url":"/features#feature-summary","position":5},{"hierarchy":{"lvl1":"Getting Started"},"type":"lvl1","url":"/getting-started","position":0},{"hierarchy":{"lvl1":"Getting Started"},"content":"This quickstart is for first-time users who want Devflow running in a repository, regardless of implementation language.","type":"content","url":"/getting-started","position":1},{"hierarchy":{"lvl1":"Getting Started","lvl2":"What You Will Achieve"},"type":"lvl2","url":"/getting-started#what-you-will-achieve","position":2},{"hierarchy":{"lvl1":"Getting Started","lvl2":"What You Will Achieve"},"content":"By the end of this page you will:\n\ninitialize a repository with dwf init (auto-detect or explicit template)\n\nrun a local quality profile (check:pr)\n\ngenerate a CI workflow from config (ci:generate)\n\nvalidate CI workflow consistency (ci:check)","type":"content","url":"/getting-started#what-you-will-achieve","position":3},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Step 1: Install Devflow"},"type":"lvl2","url":"/getting-started#step-1-install-devflow","position":4},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Step 1: Install Devflow"},"content":"Follow \n\nInstallation.","type":"content","url":"/getting-started#step-1-install-devflow","position":5},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Step 2: Initialize Project Config and Starter CI"},"type":"lvl2","url":"/getting-started#step-2-initialize-project-config-and-starter-ci","position":6},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Step 2: Initialize Project Config and Starter CI"},"content":"Recommended:dwf init\n\nThis auto-detects project type in this order:\n\nCargo.toml -> rust\n\ntsconfig.json -> tsc\n\npackage.json -> node\n\nExplicit template selection:dwf init rust\ndwf init node\ndwf init tsc\ndwf init kotlin\n\nWhat this writes:\n\ndevflow.toml\n\n.github/workflows/ci.yml\n\nUse --force to overwrite existing files:dwf --force init rust\n\nIf you prefer manual setup, create devflow.toml in your repository root.\n\nTypeScript example:[project]\nname = \"my-ts-repo\"\nstack = [\"node\"]\n\n[runtime]\n# Runtime execution profile: container | host | auto\nprofile = \"auto\"\n\n[targets]\npr = [\"fmt:check\", \"lint:static\", \"build:debug\", \"test:unit\"]\nmain = [\"fmt:check\", \"lint:static\", \"build:release\", \"test:unit\", \"test:integration\"]\n\n[extensions.node]\nsource = \"builtin\"\nrequired = true","type":"content","url":"/getting-started#step-2-initialize-project-config-and-starter-ci","position":7},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Step 3: Run Local Quality Gate"},"type":"lvl2","url":"/getting-started#step-3-run-local-quality-gate","position":8},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Step 3: Run Local Quality Gate"},"content":"dwf check:pr\n\nWhat this does:\n\nloads the targets.pr command list from devflow.toml\n\nruns each listed command locally, in order\n\nreturns non-zero exit code if any command fails\n\nWhat this does not do:\n\nit does not call remote CI services\n\nit does not push commits or modify your Git provider settings","type":"content","url":"/getting-started#step-3-run-local-quality-gate","position":9},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Step 4: Generate and Validate CI Workflow"},"type":"lvl2","url":"/getting-started#step-4-generate-and-validate-ci-workflow","position":10},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Step 4: Generate and Validate CI Workflow"},"content":"dwf ci:generate\ndwf ci:check\n\nExpected behavior:\n\nci:generate writes .github/workflows/ci.yml\n\nre-running ci:generate re-syncs the file from current config\n\nci:check validates topology and detects drift between committed workflow and generated workflow","type":"content","url":"/getting-started#step-4-generate-and-validate-ci-workflow","position":11},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Step 5: Inspect Planned Profiles"},"type":"lvl2","url":"/getting-started#step-5-inspect-planned-profiles","position":12},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Step 5: Inspect Planned Profiles"},"content":"dwf ci:plan\n\nThis prints the target profile names currently defined in [targets].","type":"content","url":"/getting-started#step-5-inspect-planned-profiles","position":13},{"hierarchy":{"lvl1":"Installation"},"type":"lvl1","url":"/installation","position":0},{"hierarchy":{"lvl1":"Installation"},"content":"","type":"content","url":"/installation","position":1},{"hierarchy":{"lvl1":"Installation","lvl2":"Prerequisites"},"type":"lvl2","url":"/installation#prerequisites","position":2},{"hierarchy":{"lvl1":"Installation","lvl2":"Prerequisites"},"content":"macOS or Linux shell environment\n\nRust toolchain (required only for current source-based install path)\n\ncargo available in PATH\n\nYou do not need to know Rust internals to use Devflow, but the current bootstrap build path uses Rust until binary distribution channels are published.","type":"content","url":"/installation#prerequisites","position":3},{"hierarchy":{"lvl1":"Installation","lvl2":"Install via Script"},"type":"lvl2","url":"/installation#install-via-script","position":4},{"hierarchy":{"lvl1":"Installation","lvl2":"Install via Script"},"content":"From repository root:./install.sh\n\nWhat this does:\n\nbuilds dwf in release mode\n\ninstalls binary to ${HOME}/.local/bin/dwf (or custom DWF_INSTALL_DIR)","type":"content","url":"/installation#install-via-script","position":5},{"hierarchy":{"lvl1":"Installation","lvl2":"Verify Installation"},"type":"lvl2","url":"/installation#verify-installation","position":6},{"hierarchy":{"lvl1":"Installation","lvl2":"Verify Installation"},"content":"dwf --help\ndwf ci:plan\n\nIf dwf is not found, add ${HOME}/.local/bin to your PATH.","type":"content","url":"/installation#verify-installation","position":7},{"hierarchy":{"lvl1":"New Stacks (Kotlin Example)"},"type":"lvl1","url":"/new-stacks","position":0},{"hierarchy":{"lvl1":"New Stacks (Kotlin Example)"},"content":"If your stack is not natively mapped yet, use Devflow with stack = [\"custom\"].\n\nThis keeps canonical Devflow commands while delegating implementation details to your existing build tool.","type":"content","url":"/new-stacks","position":1},{"hierarchy":{"lvl1":"New Stacks (Kotlin Example)","lvl2":"Step 1: Initialize with Kotlin Template"},"type":"lvl2","url":"/new-stacks#step-1-initialize-with-kotlin-template","position":2},{"hierarchy":{"lvl1":"New Stacks (Kotlin Example)","lvl2":"Step 1: Initialize with Kotlin Template"},"content":"dwf init kotlin\n\nThis generates a custom stack config and starter CI workflow.","type":"content","url":"/new-stacks#step-1-initialize-with-kotlin-template","position":3},{"hierarchy":{"lvl1":"New Stacks (Kotlin Example)","lvl2":"Step 2: Provide Targets in justfile or Makefile"},"type":"lvl2","url":"/new-stacks#step-2-provide-targets-in-justfile-or-makefile","position":4},{"hierarchy":{"lvl1":"New Stacks (Kotlin Example)","lvl2":"Step 2: Provide Targets in justfile or Makefile"},"content":"Example Makefile:fmt-check:\n\t./gradlew ktlintCheck\n\nlint-static:\n\t./gradlew detekt\n\nbuild-debug:\n\t./gradlew build -x test\n\ntest-unit:\n\t./gradlew test\n\ntest-integration:\n\t./gradlew integrationTest","type":"content","url":"/new-stacks#step-2-provide-targets-in-justfile-or-makefile","position":5},{"hierarchy":{"lvl1":"New Stacks (Kotlin Example)","lvl2":"Step 3: Run Canonical Commands"},"type":"lvl2","url":"/new-stacks#step-3-run-canonical-commands","position":6},{"hierarchy":{"lvl1":"New Stacks (Kotlin Example)","lvl2":"Step 3: Run Canonical Commands"},"content":"dwf check:pr\ndwf ci:generate\ndwf ci:check","type":"content","url":"/new-stacks#step-3-run-canonical-commands","position":7},{"hierarchy":{"lvl1":"New Stacks (Kotlin Example)","lvl2":"Roadblock Avoidance Checklist"},"type":"lvl2","url":"/new-stacks#roadblock-avoidance-checklist","position":8},{"hierarchy":{"lvl1":"New Stacks (Kotlin Example)","lvl2":"Roadblock Avoidance Checklist"},"content":"keep target names aligned with canonical selectors (: -> -)\n\nensure your local runner (just or make) is installed in both local and CI images\n\nstart with fmt:check, lint:static, build:debug, test:unit; add more selectors incrementally\n\nuse dwf --stdout ci:generate to inspect workflow output before overwriting files","type":"content","url":"/new-stacks#roadblock-avoidance-checklist","position":9},{"hierarchy":{"lvl1":"Troubleshooting"},"type":"lvl1","url":"/troubleshooting","position":0},{"hierarchy":{"lvl1":"Troubleshooting"},"content":"","type":"content","url":"/troubleshooting","position":1},{"hierarchy":{"lvl1":"Troubleshooting","lvl2":"Unknown command selector in targets"},"type":"lvl2","url":"/troubleshooting#unknown-command-selector-in-targets","position":2},{"hierarchy":{"lvl1":"Troubleshooting","lvl2":"Unknown command selector in targets"},"content":"Run dwf check:pr and fix unsupported selectors in targets.*.","type":"content","url":"/troubleshooting#unknown-command-selector-in-targets","position":3},{"hierarchy":{"lvl1":"Troubleshooting","lvl2":"Extension path errors"},"type":"lvl2","url":"/troubleshooting#extension-path-errors","position":4},{"hierarchy":{"lvl1":"Troubleshooting","lvl2":"Extension path errors"},"content":"For source = \"path\", ensure path exists and is readable.","type":"content","url":"/troubleshooting#extension-path-errors","position":5},{"hierarchy":{"lvl1":"Troubleshooting","lvl2":"Tool not found during execution"},"type":"lvl2","url":"/troubleshooting#tool-not-found-during-execution","position":6},{"hierarchy":{"lvl1":"Troubleshooting","lvl2":"Tool not found during execution"},"content":"Install required toolchain commands (cargo, npm, etc.) for configured stacks.","type":"content","url":"/troubleshooting#tool-not-found-during-execution","position":7},{"hierarchy":{"lvl1":"User Guide"},"type":"lvl1","url":"/user-index","position":0},{"hierarchy":{"lvl1":"User Guide"},"content":"","type":"content","url":"/user-index","position":1},{"hierarchy":{"lvl1":"User Guide","lvl2":"Who This Is For"},"type":"lvl2","url":"/user-index#who-this-is-for","position":2},{"hierarchy":{"lvl1":"User Guide","lvl2":"Who This Is For"},"content":"This guide is for engineers and teams who want a consistent developer workflow across local machines and CI, without every repository inventing its own scripts and check logic.\n\nTypical users:\n\nbackend teams (Rust, Node, polyglot repos)\n\nfrontend teams that need repeatable quality gates\n\nplatform teams standardizing CI workflows across projects","type":"content","url":"/user-index#who-this-is-for","position":3},{"hierarchy":{"lvl1":"User Guide","lvl2":"Mission and Objectives"},"type":"lvl2","url":"/user-index#mission-and-objectives","position":4},{"hierarchy":{"lvl1":"User Guide","lvl2":"Mission and Objectives"},"content":"Devflow exists to make workflow behavior predictable and shareable.\n\nObjectives:\n\none canonical command surface across stacks\n\nprofile-driven quality gates (targets.*) instead of ad hoc scripts\n\nreproducible local and CI behavior\n\nextension model that lets projects map canonical commands to stack tooling","type":"content","url":"/user-index#mission-and-objectives","position":5},{"hierarchy":{"lvl1":"User Guide","lvl2":"Positioning"},"type":"lvl2","url":"/user-index#positioning","position":6},{"hierarchy":{"lvl1":"User Guide","lvl2":"Positioning"},"content":"Devflow does not replace Makefile or justfile. It adds a consistent command contract and profile policy layer across repositories, while Make/Just can continue to execute stack-specific internals.","type":"content","url":"/user-index#positioning","position":7},{"hierarchy":{"lvl1":"User Guide","lvl2":"Why This Matters"},"type":"lvl2","url":"/user-index#why-this-matters","position":8},{"hierarchy":{"lvl1":"User Guide","lvl2":"Why This Matters"},"content":"Without a shared workflow contract, local and CI behavior drifts. Teams duplicate shell scripts, command names vary by project, and debugging failed CI becomes expensive.\n\nDevflow turns this into a config-defined contract that can be executed and validated consistently.","type":"content","url":"/user-index#why-this-matters","position":9},{"hierarchy":{"lvl1":"User Guide","lvl2":"Start Here"},"type":"lvl2","url":"/user-index#start-here","position":10},{"hierarchy":{"lvl1":"User Guide","lvl2":"Start Here"},"content":"Problem and Workflow Model\n\nCore Principles and Features\n\nInstallation\n\nGetting Started\n\nConfiguration\n\nNew Stacks (Kotlin Example)","type":"content","url":"/user-index#start-here","position":11},{"hierarchy":{"lvl1":"Problem and Workflow Model"},"type":"lvl1","url":"/workflow-model","position":0},{"hierarchy":{"lvl1":"Problem and Workflow Model"},"content":"","type":"content","url":"/workflow-model","position":1},{"hierarchy":{"lvl1":"Problem and Workflow Model","lvl2":"Typical Workflow Today (Without Devflow)"},"type":"lvl2","url":"/workflow-model#typical-workflow-today-without-devflow","position":2},{"hierarchy":{"lvl1":"Problem and Workflow Model","lvl2":"Typical Workflow Today (Without Devflow)"},"content":"flowchart LR\n    local1[\"Local scripts: npm run lint\"]\n    local2[\"Local scripts: cargo test\"]\n    local3[\"Custom make targets\"]\n    ci1[\"CI YAML job A\"]\n    ci2[\"CI YAML job B\"]\n    ci3[\"Repo-specific glue scripts\"]\n\n    local1 --> ci1\n    local2 --> ci2\n    local3 --> ci3\n\nCommon issues:\n\nduplicate logic across scripts, Makefiles, and CI YAML\n\ninconsistent command names across repositories\n\nlocal success but CI failure due to workflow drift","type":"content","url":"/workflow-model#typical-workflow-today-without-devflow","position":3},{"hierarchy":{"lvl1":"Problem and Workflow Model","lvl2":"Workflow With Devflow"},"type":"lvl2","url":"/workflow-model#workflow-with-devflow","position":4},{"hierarchy":{"lvl1":"Problem and Workflow Model","lvl2":"Workflow With Devflow"},"content":"flowchart LR\n    cfg[\"devflow.toml\"]\n    cli[\"dwf command surface\"]\n    ext[\"stack extensions\"]\n    local[\"local execution\"]\n    ci[\"generated CI workflow\"]\n\n    cfg --> cli\n    cli --> ext\n    ext --> local\n    cfg --> ci\n    cli --> ci\n\nBenefits:\n\nsame commands locally and in CI\n\nDRY policy definition in targets.*\n\nreproducible workflow generation and validation (ci:generate, ci:check)","type":"content","url":"/workflow-model#workflow-with-devflow","position":5}]}